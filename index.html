
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ÌôòÏû•RPG</title>
    <style>
        :root {
            --background-color: #1a1a1a;
            --surface-color: rgba(44, 44, 44, 0.85);
            --primary-color: #bb86fc;
            --secondary-color: #03dac6;
            --text-color: #e0e0e0;
            --border-color: #444;
            --font-family: 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;

            --grade-common: #ffffff;
            --grade-uncommon: #1eff00;
            --grade-rare: #0070dd;
            --grade-epic: #a335ee;
            --grade-legendary: #ff8000;
        }

        body {
            background-color: var(--background-color);
            background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://images.unsplash.com/photo-1549468057-5b7211421415?q=80&w=1974&auto=format&fit=crop');
            background-size: cover;
            background-position: center center;
            background-attachment: fixed;
            background-repeat: no-repeat;
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 20px;
            overscroll-behavior: none;
        }

        #root {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        h1, h2, h3, h4, h5 {
            color: var(--primary-color);
            margin-top: 0;
        }

        button {
            background-color: var(--primary-color);
            color: #121212;
            border: none;
            border-radius: 4px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        button:hover {
            background-color: var(--secondary-color);
        }
        
        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
        }
        
        input[type="text"] {
            background-color: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px;
            border-radius: 4px;
        }
        
        .edit-name-btn {
            background: none;
            border: none;
            padding: 0 5px;
            font-size: 1em;
            cursor: pointer;
        }

        /* Grades */
        .grade-common { color: var(--grade-common); }
        .grade-uncommon { color: var(--grade-uncommon); }
        .grade-rare { color: var(--grade-rare); }
        .grade-epic { color: var(--grade-epic); }
        .grade-legendary { color: var(--grade-legendary); font-weight: bold; }

        /* Stat Bar */
        .stat-bar-container { margin-bottom: 10px; }
        .stat-bar {
            background-color: #333;
            border-radius: 4px;
            overflow: hidden;
            height: 18px;
            border: 1px solid var(--border-color);
        }
        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease-in-out;
        }

        /* Town View */
        .town-layout {
            text-align: center;
        }
        .town-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 20px;
            margin-bottom: 30px;
        }
        .town-main-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .town-main-actions button {
            padding: 20px;
            font-size: 1.5em;
            font-weight: bold;
        }


        /* Shop & Inventory */
        .shop-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .shop-tabs button {
            background: none;
            border: none;
            color: var(--text-color);
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .shop-tabs button.active {
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
        }

        .shop-grid, .inventory-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .item-card {
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        
        .item-card.selected {
            background-color: rgba(3, 218, 198, 0.2);
            box-shadow: 0 0 10px var(--secondary-color);
        }
        
        .inventory-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        .inventory-item button {
            font-size: 0.8em;
            padding: 5px 8px;
        }

        /* Battle View */
        .combat-screen {
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            margin-bottom: 20px;
            min-height: 200px;
        }

        .character-container {
            width: 45%;
            text-align: center;
        }

        .character {
            font-size: 4em;
            transition: transform 0.2s ease-in-out;
            display: inline-block;
        }
        
        .pet-character {
            font-size: 2em;
            position: relative;
            left: -10px;
            bottom: -20px;
        }

        .player-side.attacking .character {
            transform: translateX(20px) scale(1.1);
        }
        .enemy-side.attacking .character {
            transform: translateX(-20px) scale(1.1);
        }

        .battle-log {
            height: 150px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            padding: 10px;
            margin-top: 20px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        
        .battle-log p {
            margin: 0 0 5px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        .player-turn { color: #81d4fa; }
        .enemy-turn { color: #f48fb1; }
        .system-message { color: #fff59d; font-style: italic; }
        .effect-message { color: #a5d6a7; }
        .pet-skill-message { color: var(--secondary-color); font-weight: bold; }

        .battle-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        .ultimate-button {
            background-color: #ff8f00;
        }
        .ultimate-button:disabled {
            background-color: #555;
        }

        /* Damage Popups */
        .damage-popup {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            animation: floatUp 0.6s ease-out forwards;
            text-shadow: 2px 2px 2px black;
        }
        
        .damage-popup.crit {
            color: #ffeb3b;
            font-size: 2em;
            font-weight: bolder;
        }
        
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        /* Modal for Battle Inventory */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            width: 80%;
            max-width: 500px;
        }

        /* Class Selection */
        .class-selection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        /* Dungeons */
        .dungeon-list, .dungeon-card-rewards ul {
             list-style: none;
             padding: 0;
        }

        /* Blacksmith */
        .blacksmith-container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }
        
        .item-list-panel .list-item {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 5px;
            cursor: pointer;
        }
        
        .item-list-panel .list-item.selected {
             background-color: rgba(3, 218, 198, 0.2);
        }

        .enhancement-stats .arrow {
            color: var(--secondary-color);
            margin: 0 5px;
        }
        
        .material-list {
            list-style: none;
            padding: 0;
        }
        .material-list .sufficient { color: var(--text-color); }
        .material-list .insufficient { color: #f48fb1; }
        
        /* Quests */
        .quest-section { margin-bottom: 30px; }
        .quest-card {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quest-card.completed { border-left: 5px solid var(--secondary-color); }
        .quest-progress-bar-container {
            width: 100%;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            margin: 5px 0;
        }
        .quest-progress-bar-fill {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 5px;
        }
        
        /* Gacha */
        .gacha-shrine { text-align: center; }
        .gacha-result {
             position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }
        .gacha-result .card { text-align: center; }
        .gacha-item-grade { font-size: 2em; margin-bottom: 10px; }
        .gacha-item-name { font-size: 1.5em; font-weight: bold; }

        /* Town Hall */
        .town-hall-upgrade-info {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }
        
        /* Trophy Road */
        .current-trophies { text-align: center; font-size: 1.2em; }
        .trophy-milestone {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            opacity: 0.5;
        }
        .trophy-milestone.unlocked { opacity: 1; }
        .trophy-milestone.claimed { background-color: rgba(3, 218, 198, 0.1); }
        
        /* Pets */
        .pet-management-view {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }

        .pet-card.active {
             background-color: rgba(3, 218, 198, 0.2);
        }
        
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18",
            "react-dom/client": "https://esm.sh/react-dom@18/client",
            "react/jsx-runtime": "https://esm.sh/react@18/jsx-runtime"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useMemo, useCallback, Fragment, useRef } from 'react';
        import ReactDOM from 'react-dom/client';

        // --- TYPES & CONSTANTS ---
        const ItemType = {
            WEAPON: 'Weapon',
            ARMOR: 'Armor',
            CONSUMABLE: 'Consumable',
            MATERIAL: 'Material',
        };

        const View = {
            TOWN: 'TOWN',
            SHOP: 'SHOP',
            PLAYER: 'PLAYER',
            BATTLE: 'BATTLE',
            RUINS: 'RUINS',
            BLACKSMITH: 'BLACKSMITH',
            QUEST_BOARD: 'QUEST_BOARD',
            DUNGEON: 'DUNGEON',
            GACHA_SHRINE: 'GACHA_SHRINE',
            TOWN_HALL: 'TOWN_HALL',
            TROPHY_ROAD: 'TROPHY_ROAD',
            PETS: 'PETS',
            CLASS_SELECTION: 'CLASS_SELECTION',
            DUNGEON_BATTLE: 'DUNGEON_BATTLE',
        };

        const ItemGrade = {
            COMMON: 'COMMON',
            UNCOMMON: 'UNCOMMON',
            RARE: 'RARE',
            EPIC: 'EPIC',
            LEGENDARY: 'LEGENDARY'
        };

        const ItemGradeInfo = {
            [ItemGrade.COMMON]: { name: 'ÏùºÎ∞ò', color: '#ffffff', class: 'grade-common', order: 1 },
            [ItemGrade.UNCOMMON]: { name: 'Í≥†Í∏â', color: '#1eff00', class: 'grade-uncommon', order: 2 },
            [ItemGrade.RARE]: { name: 'Ìù¨Í∑Ä', color: '#0070dd', class: 'grade-rare', order: 3 },
            [ItemGrade.EPIC]: { name: 'ÏòÅÏõÖ', color: '#a335ee', class: 'grade-epic', order: 4 },
            [ItemGrade.LEGENDARY]: { name: 'Ï†ÑÏÑ§', color: '#ff8000', class: 'grade-legendary', order: 5 }
        };

        const PlayerClasses = {
            Warrior: { name: 'Ï†ÑÏÇ¨', description: 'Í∞ïÏù∏Ìïú Ï≤¥Î†•Í≥º Î∞©Ïñ¥Î†•ÏùÑ Í∞ÄÏßëÎãàÎã§. (ÏµúÎåÄ HP +20, Î∞©Ïñ¥Î†• +5)', bonuses: { maxHp: 20, defense: 5, attack: 0 } },
            Archer: { name: 'Í∂ÅÏàò', description: 'ÎÜíÏùÄ Í≥µÍ≤©Î†•Í≥º ÏπòÎ™ÖÌÉÄ ÌôïÎ•†ÏùÑ ÏûêÎûëÌï©ÎãàÎã§. (Í≥µÍ≤©Î†• +5, ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +5%)', bonuses: { attack: 5, critChance: 0.05, maxHp: 0, defense: 0 } },
        };

        const UltimateSkills = {
            Adventurer: { name: 'ÌååÏõå Ïä§Ìä∏ÎùºÏù¥ÌÅ¨', description: 'Ï†ÅÏóêÍ≤å 250%Ïùò ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            Warrior: { name: 'Î∂ÑÏáÑÏùò ÏùºÍ≤©', description: 'Ï†ÅÏóêÍ≤å 300%Ïùò ÌîºÌï¥Î•º ÏûÖÌûàÍ≥† 50% ÌôïÎ•†Î°ú 1ÌÑ¥ ÎèôÏïà Í∏∞Ï†àÏãúÌÇµÎãàÎã§.' },
            Archer: { name: 'Ï†ÄÍ≤©', description: 'Î∞òÎìúÏãú ÏπòÎ™ÖÌÉÄÎ°ú Ï†ÅÏ§ëÌïòÎäî Í∞ïÎ†•Ìïú ÌôîÏÇ¥ÏùÑ Î∞úÏÇ¨Ìï©ÎãàÎã§. (Í∏∞Î≥∏ ÏπòÎ™ÖÌÉÄ ÌîºÌï¥ÎüâÏùò 200%)' }
        };

        const PET_GACHA_COST = 500;
        const ITEM_GACHA_COST = 300;


        const allPets = [
            { id: 1, name: 'Í∑∏Î¶¨ÌïÄ Ï£ºÎãàÏñ¥', type: 'Griffin', grade: ItemGrade.RARE, attackBonus: 5, defenseBonus: 0, skillName: 'Ìï†ÌÄ¥Í∏∞', skillDescription: '15% ÌôïÎ•†Î°ú Ï∂îÍ∞Ä ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.', skillProcChance: 0.15, skillEffect: { type: 'damage', amount: 10 } },
            { id: 2, name: 'ÎèåÎ∂ÅÏù¥', type: 'Turtle', grade: ItemGrade.RARE, attackBonus: 0, defenseBonus: 8, skillName: 'Îã®Îã®Ìï¥ÏßÄÍ∏∞', skillDescription: 'Ï†ÑÌà¨ ÏãúÏûë Ïãú Î∞©Ïñ¥Î†•Ïù¥ 10% Ï¶ùÍ∞ÄÌï©ÎãàÎã§.', skillProcChance: 1.0 }, // Always active at start
            { id: 3, name: 'ÏïÑÍ∏∞Ïö©', type: 'Dragon', grade: ItemGrade.EPIC, attackBonus: 10, defenseBonus: 5, skillName: 'ÏûëÏùÄ Î∂àÏî®', skillDescription: '20% ÌôïÎ•†Î°ú Í∞ïÎ†•Ìïú ÌôîÏóº ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.', skillProcChance: 0.20, skillEffect: { type: 'damage', amount: 25 } },
        ];


        // --- DATABASE ---
        const allItems = [
            // --- Í∏∞Ï°¥ ÏïÑÏù¥ÌÖú ---
            { id: 1, type: ItemType.WEAPON, name: 'ÎÇòÎ¨¥ Î™ΩÎë•Ïù¥', price: 15, grade: ItemGrade.COMMON, damage: 3, accuracy: 0.8, description: 'ÌùîÌïú ÎÇòÎ¨¥ Î™ΩÎë•Ïù¥ÏûÖÎãàÎã§.' },
            { id: 2, type: ItemType.WEAPON, name: 'ÎÇ°ÏùÄ Í≤Ä', price: 60, grade: ItemGrade.COMMON, damage: 5, accuracy: 0.9, description: 'Í∞ÄÏû• Í∏∞Î≥∏Ï†ÅÏù∏ Í≤ÄÏûÖÎãàÎã§. ÏóÜÎäî Í≤ÉÎ≥¥Îã® ÎÇ´ÏäµÎãàÎã§.' },
            { id: 3, type: ItemType.WEAPON, name: 'Í∞ïÏ≤† Í≤Ä', price: 300, grade: ItemGrade.UNCOMMON, damage: 10, accuracy: 0.9, critChance: 0.05, critDamageMultiplier: 1.5, description: 'Ïûò Î≤ºÎ†§ÏßÑ Í∞ïÏ≤† Í≤ÄÏûÖÎãàÎã§.' },
            { id: 4, type: ItemType.ARMOR, name: 'Í∞ÄÏ£Ω Í∞ëÏò∑', price: 120, grade: ItemGrade.UNCOMMON, defense: 5, description: 'ÏßàÍ∏¥ Í∞ÄÏ£ΩÏúºÎ°ú ÎßåÎì† Í∞ëÏò∑ÏûÖÎãàÎã§.' },
            { id: 5, type: ItemType.CONSUMABLE, name: 'ÌïòÍ∏â Ï≤¥Î†• Î¨ºÏïΩ', price: 20, grade: ItemGrade.COMMON, effect: { type: 'heal', amount: 20 }, description: 'HPÎ•º 20 ÌöåÎ≥µÌï©ÎãàÎã§.' },
            { id: 6, type: ItemType.MATERIAL, name: 'Ï≤†Í¥ëÏÑù', price: 10, grade: ItemGrade.COMMON, description: 'Í∞ïÏ≤†ÏùÑ ÎßåÎìúÎäî Îç∞ ÏÇ¨Ïö©ÎêòÎäî Í∏∞Î≥∏Ï†ÅÏù∏ Í¥ëÎ¨ºÏûÖÎãàÎã§.' },
            { id: 7, type: ItemType.MATERIAL, name: 'Í∞ÄÏ£Ω', price: 8, grade: ItemGrade.COMMON, description: 'ÎèôÎ¨ºÏóêÍ≤åÏÑú ÏñªÏùÑ Ïàò ÏûàÎäî ÏßàÍ∏¥ Í∞ÄÏ£ΩÏûÖÎãàÎã§.' },
            { id: 8, type: ItemType.WEAPON, name: 'ÏßÄÌúòÍ¥ÄÏùò Ï∞Ω', price: 2000, grade: ItemGrade.EPIC, damage: 25, accuracy: 0.95, critChance: 0.1, critDamageMultiplier: 1.8, procChance: 0.1, procDamage: 10, description: 'Ï†ÑÏû•ÏùÑ ÏßÄÌúòÌïòÎäî ÏßÄÌúòÍ¥ÄÏùò Ï∞Ω. 10% ÌôïÎ•†Î°ú Ï∂îÍ∞Ä ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            { id: 9, type: ItemType.ARMOR, name: 'Í∞ïÏ≤† Í∞ëÏò∑', price: 650, grade: ItemGrade.RARE, defense: 15, description: 'Í≤¨Í≥†Ìïú Í∞ïÏ≤†Î°ú ÎßåÎì§Ïñ¥ÏßÑ Í∞ëÏò∑ÏûÖÎãàÎã§.' },
            { id: 10, type: ItemType.WEAPON, name: 'ÏóòÌîÑÏùò Ìôú', price: 2400, grade: ItemGrade.EPIC, weaponType: 'Bow', damage: 22, accuracy: 1.1, critChance: 0.15, critDamageMultiplier: 2.0, description: 'Ïã†ÎπÑÎ°úÏö¥ ÌûòÏù¥ ÍπÉÎì† ÏóòÌîÑÏùò Ìôú. Î™ÖÏ§ëÎ•†Ïù¥ Îß§Ïö∞ ÎÜíÏäµÎãàÎã§.' },
            { id: 11, type: ItemType.WEAPON, name: 'Ï≤úÍ≥µÏùò Î∂ÑÎÖ∏', price: 12500, grade: ItemGrade.LEGENDARY, damage: 50, accuracy: 0.9, critChance: 0.2, critDamageMultiplier: 2.5, description: 'ÌïòÎäòÏùò Î∂ÑÎÖ∏Î•º Îã¥ÏùÄ Ï†ÑÏÑ§Ï†ÅÏù∏ Í≤ÄÏûÖÎãàÎã§.' },
            { id: 12, type: ItemType.MATERIAL, name: 'ÎßàÎ†•Ïùò Îèå', price: 100, grade: ItemGrade.RARE, description: 'Ïã†ÎπÑÌïú ÎßàÎ†•Ïù¥ ÍπÉÎì† Îèå. Í∞ïÌôîÏóê ÏÇ¨Ïö©Îê©ÎãàÎã§.' },

            // --- Ïã†Í∑ú Î¨¥Í∏∞ ---
            // Common
            { id: 13, type: ItemType.WEAPON, name: 'Îã®Í≤Ä', price: 50, grade: ItemGrade.COMMON, damage: 4, accuracy: 0.95, critChance: 0.05, critDamageMultiplier: 1.6, description: 'Îπ†Î•∏ Í≥µÍ≤©Ïù¥ Í∞ÄÎä•Ìïú ÏûëÏùÄ Í≤ÄÏûÖÎãàÎã§.' },
            { id: 14, type: ItemType.WEAPON, name: 'Í∏ÄÎùºÎîîÏö∞Ïä§', price: 75, grade: ItemGrade.COMMON, damage: 6, accuracy: 0.9, description: 'Î°úÎßà Î≥ëÏÇ¨Îì§Ïù¥ ÏÇ¨Ïö©ÌïòÎçò ÏßßÏùÄ Í≤ÄÏûÖÎãàÎã§.' },
            { id: 15, type: ItemType.WEAPON, name: 'ÏÜêÎèÑÎÅº', price: 55, grade: ItemGrade.COMMON, damage: 5, accuracy: 0.85, description: 'Ìïú ÏÜêÏúºÎ°ú Îã§Î£®Í∏∞ Ïâ¨Ïö¥ ÎèÑÎÅºÏûÖÎãàÎã§.' },
            { id: 16, type: ItemType.WEAPON, name: 'ÏøºÌÑ∞Ïä§ÌÉúÌîÑ', price: 45, grade: ItemGrade.COMMON, damage: 4, accuracy: 0.9, description: 'Îã®Îã®Ìïú ÎÇòÎ¨¥Î°ú ÎßåÎì† Í∏¥ ÏßÄÌå°Ïù¥ÏûÖÎãàÎã§.' },
            { id: 17, type: ItemType.WEAPON, name: 'ÎßùÏπò', price: 20, grade: ItemGrade.COMMON, damage: 4, accuracy: 0.75, description: 'ÌèâÎ≤îÌïú ÎßùÏπòÏûÖÎãàÎã§.' },

            // Uncommon
            { id: 18, type: ItemType.WEAPON, name: 'ÏïÑÏù¥Ïñ∏ Ïï°Ïä§', price: 330, grade: ItemGrade.UNCOMMON, damage: 12, accuracy: 0.85, description: 'Î¨µÏßÅÌïú Ï≤†Ï†ú ÎèÑÎÅºÏûÖÎãàÎã§.' },
            { id: 19, type: ItemType.WEAPON, name: 'ÏàèÎ≥¥Ïö∞', price: 270, grade: ItemGrade.UNCOMMON, weaponType: 'Bow', damage: 8, accuracy: 1.0, critChance: 0.1, critDamageMultiplier: 1.6, description: 'Îã§Î£®Í∏∞ Ïâ¨Ïö¥ ÏßßÏùÄ ÌôúÏûÖÎãàÎã§.' },
            { id: 20, type: ItemType.WEAPON, name: 'Î°±ÏÜåÎìú', price: 375, grade: ItemGrade.UNCOMMON, damage: 11, accuracy: 0.9, critChance: 0.05, critDamageMultiplier: 1.5, description: 'Í∑†Ìòï Ïû°Ìûå Ïû•Í≤ÄÏûÖÎãàÎã§.' },
            { id: 21, type: ItemType.WEAPON, name: 'Ïä§ÌîºÏñ¥', price: 315, grade: ItemGrade.UNCOMMON, damage: 9, accuracy: 0.95, description: 'Í∏¥ ÏÇ¨Ï†ïÍ±∞Î¶¨Î•º Í∞ÄÏßÑ Ï∞ΩÏûÖÎãàÎã§.' },
            { id: 22, type: ItemType.WEAPON, name: 'ÏãúÎØ∏ÌÑ∞', price: 360, grade: ItemGrade.UNCOMMON, damage: 10, accuracy: 0.9, critChance: 0.08, critDamageMultiplier: 1.6, description: 'ÏïÑÎ¶ÑÎã§Ïö¥ Í≥°ÏÑ† ÌòïÌÉúÏùò Í≤ÄÏûÖÎãàÎã§.' },
            { id: 23, type: ItemType.WEAPON, name: 'Ïá†Îáå', price: 450, grade: ItemGrade.UNCOMMON, weaponType: 'Bow', damage: 14, accuracy: 0.8, description: 'Í∞ïÎ†•ÌïòÏßÄÎßå Ïû•Ï†ÑÏù¥ ÎäêÎ¶∞ Ïá†ÎáåÏûÖÎãàÎã§.' },
            { id: 24, type: ItemType.WEAPON, name: 'Î©îÏù¥Ïä§', price: 345, grade: ItemGrade.UNCOMMON, damage: 10, accuracy: 0.9, description: 'ÎëîÍ∏∞Î•ò Î¨¥Í∏∞ÏûÖÎãàÎã§.' },

            // Rare
            { id: 25, type: ItemType.WEAPON, name: 'Î∏åÎ°úÎìúÏÜåÎìú', price: 1260, grade: ItemGrade.RARE, damage: 18, accuracy: 0.9, description: 'ÎÑìÏùÄ ÏπºÎÇ†ÏùÑ Í∞ÄÏßÑ ÏúÑÎ†•Ï†ÅÏù∏ Í≤ÄÏûÖÎãàÎã§.' },
            { id: 26, type: ItemType.WEAPON, name: 'ÎØ∏Ïä§Î¶¥ Îã®Í≤Ä', price: 1530, grade: ItemGrade.RARE, damage: 15, accuracy: 1.0, critChance: 0.15, critDamageMultiplier: 1.8, description: 'Í∞ÄÎ≥çÍ≥† ÎÇ†Ïπ¥Î°úÏö¥ ÎØ∏Ïä§Î¶¥ Îã®Í≤ÄÏûÖÎãàÎã§.' },
            { id: 27, type: ItemType.WEAPON, name: 'ÏõåÌï¥Î®∏', price: 1620, grade: ItemGrade.RARE, damage: 22, accuracy: 0.8, description: 'Ï†ÅÏùò Î∞©Ïñ¥Íµ¨Î•º Î∂ÄÏàòÎäî Ïú°Ï§ëÌïú ÎßùÏπòÏûÖÎãàÎã§.' },
            { id: 28, type: ItemType.WEAPON, name: 'Í∑∏Î†àÏù¥Ìä∏ÏÜåÎìú', price: 1440, grade: ItemGrade.RARE, damage: 20, accuracy: 0.85, description: 'ÏñëÏÜêÏúºÎ°ú ÏÇ¨Ïö©ÌïòÎäî Í±∞ÎåÄÌïú Í≤ÄÏûÖÎãàÎã§.' },
            { id: 29, type: ItemType.WEAPON, name: 'Î°±Î≥¥Ïö∞', price: 1350, grade: ItemGrade.RARE, weaponType: 'Bow', damage: 16, accuracy: 1.0, critChance: 0.12, critDamageMultiplier: 1.7, description: 'Î®º Í±∞Î¶¨Ïùò Ï†ÅÏùÑ Ï†ÄÍ≤©ÌïòÎäî Ïû•Í∂ÅÏûÖÎãàÎã§.' },
            { id: 30, type: ItemType.WEAPON, name: 'Î™®ÎãùÏä§ÌÉÄ', price: 1470, grade: ItemGrade.RARE, damage: 19, accuracy: 0.88, procChance: 0.15, procDamage: 8, description: 'Ï≤†Ìá¥ ÎÅùÏóê Í∞ÄÏãúÍ∞Ä Î∞ïÌòÄÏûàÏäµÎãàÎã§. 15% ÌôïÎ•†Î°ú Ï∂îÍ∞Ä ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            { id: 31, type: ItemType.WEAPON, name: 'ÌÅ¥Î†àÏù¥Î™®Ïñ¥', price: 1530, grade: ItemGrade.RARE, damage: 21, accuracy: 0.8, description: 'Ïä§ÏΩîÌãÄÎûúÎìúÏùò ÏñëÏÜê Í≤ÄÏûÖÎãàÎã§.' },

            // Epic
            { id: 32, type: ItemType.WEAPON, name: 'Í∏∞ÏÇ¨Ïùò Í≤Ä', price: 3000, grade: ItemGrade.EPIC, damage: 30, accuracy: 0.95, critChance: 0.1, critDamageMultiplier: 1.7, description: 'ÏôïÍµ≠ÏùÑ ÏàòÌò∏ÌïòÎäî Í∏∞ÏÇ¨ÏóêÍ≤å Ï£ºÏñ¥ÏßÄÎäî Í≤ÄÏûÖÎãàÎã§.' },
            { id: 33, type: ItemType.WEAPON, name: 'ÏïîÏÇ¥ÏûêÏùò ÏπºÎÇ†', price: 3600, grade: ItemGrade.EPIC, damage: 25, accuracy: 1.1, critChance: 0.25, critDamageMultiplier: 2.2, description: 'Ïñ¥Îë† ÏÜçÏóêÏÑú Ï†ÅÏùò Ïã¨Ïû•ÏùÑ ÎÖ∏Î¶¨Îäî ÏπºÎÇ†ÏûÖÎãàÎã§.' },
            { id: 34, type: ItemType.WEAPON, name: 'Î£¨ Î∏îÎ†àÏù¥Îìú', price: 3200, grade: ItemGrade.EPIC, damage: 28, accuracy: 0.9, procChance: 0.1, procDamage: 15, description: 'Í≥†ÎåÄ Î£¨ Î¨∏ÏûêÍ∞Ä ÏÉàÍ≤®Ï†∏ ÎßàÎ≤ïÏùò ÌûòÏùÑ Î∞úÌúòÌï©ÎãàÎã§. 10% ÌôïÎ•†Î°ú ÎßàÎ≤ï ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            { id: 35, type: ItemType.WEAPON, name: 'Ïπ¥ÌÉÄÎÇò', price: 3400, grade: ItemGrade.EPIC, damage: 26, accuracy: 1.0, critChance: 0.2, critDamageMultiplier: 2.0, description: 'ÎèôÎ∞©Ïùò Ïû•Ïù∏Ïù¥ ÎßåÎì† ÏòàÎ¶¨Ìïú ÎèÑÏûÖÎãàÎã§.' },
            { id: 36, type: ItemType.WEAPON, name: 'ÌïºÎ≤ÑÎìú', price: 3100, grade: ItemGrade.EPIC, damage: 32, accuracy: 0.85, description: 'Ï∞ΩÍ≥º ÎèÑÎÅºÎ•º Ìï©Ïπú ÌòïÌÉúÏùò Í∞ïÎ†•Ìïú Ìè¥ÏïîÏûÖÎãàÎã§.' },
            { id: 37, type: ItemType.WEAPON, name: 'Í±¥Î∏îÎ†àÏù¥Îìú', price: 3800, grade: ItemGrade.EPIC, weaponType: 'Gun', damage: 27, accuracy: 0.95, critChance: 0.15, critDamageMultiplier: 1.8, description: 'Ï¥ùÍ≥º Í≤ÄÏù¥ Í≤∞Ìï©Îêú ÌïòÏù¥Î∏åÎ¶¨Îìú Î¨¥Í∏∞ÏûÖÎãàÎã§.' },

            // Legendary
            { id: 38, type: ItemType.WEAPON, name: 'ÏóëÏä§ÏπºÎ¶¨Î≤Ñ', price: 25000, grade: ItemGrade.LEGENDARY, damage: 60, accuracy: 1.0, critChance: 0.2, critDamageMultiplier: 2.5, procChance: 0.2, procDamage: 30, description: 'ÏÑ†ÌÉùÎ∞õÏùÄ ÏôïÏùò Ï†ÑÏÑ§Ï†ÅÏù∏ ÏÑ±Í≤Ä. 20% ÌôïÎ•†Î°ú Ïã†ÏÑ±Ìïú ÎπõÏùò Ï∂îÍ∞Ä ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            { id: 39, type: ItemType.WEAPON, name: 'ÎìúÎûòÍ≥§ Ïä¨Î†àÏù¥Ïñ¥', price: 20000, grade: ItemGrade.LEGENDARY, damage: 70, accuracy: 0.85, description: 'Ïö©Ïùò ÎπÑÎäòÎßàÏ†Ä Íø∞Îö´Îäî Í±∞ÎåÄÌïú ÎåÄÍ≤ÄÏûÖÎãàÎã§.' },
            { id: 40, type: ItemType.WEAPON, name: 'Ïä§ÌÜ∞Î∏åÎßÅÏñ¥', price: 21250, grade: ItemGrade.LEGENDARY, weaponType: 'Bow', damage: 55, accuracy: 1.2, critChance: 0.25, critDamageMultiplier: 2.2, description: 'Ìè≠ÌíçÏùò ÌûòÏùÑ Îã¥ÏïÑ Î≤àÍ∞úÏùò ÌôîÏÇ¥ÏùÑ ÏèòÎäî ÌôúÏûÖÎãàÎã§.' },
            { id: 41, type: ItemType.WEAPON, name: 'Í≤åÏù¥Î≥ºÍ∑∏', price: 22500, grade: ItemGrade.LEGENDARY, damage: 65, accuracy: 0.95, critChance: 0.15, critDamageMultiplier: 2.0, procChance: 0.3, procDamage: 25, description: 'ÎçòÏßÄÎ©¥ Î∞òÎìúÏãú Ïã¨Ïû•ÏùÑ Íø∞Îö´ÎäîÎã§Îäî Ï†ÄÏ£ºÎ∞õÏùÄ ÎßàÏ∞Ω. 30% ÌôïÎ•†Î°ú Ï∂úÌòà ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            { id: 42, type: ItemType.WEAPON, name: 'ÏÑÄÎèÑÏö∞ÌåΩ', price: 23750, grade: ItemGrade.LEGENDARY, damage: 50, accuracy: 1.1, critChance: 0.3, critDamageMultiplier: 2.8, description: 'Í∑∏Î¶ºÏûêÏóêÏÑú Î≤ºÎ†§ÎÇ∏ Îã®Í≤Ä. ÏπòÎ™ÖÌÉÄÏóê ÌäπÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.' },

            // --- Ïã†Í∑ú Î∞©Ïñ¥Íµ¨ ---
            { id: 43, type: ItemType.ARMOR, name: 'Ï≤ú Í∞ëÏò∑', price: 30, grade: ItemGrade.COMMON, defense: 2, description: 'Í∞ÄÏû• Í∏∞Î≥∏Ï†ÅÏù∏ Ï≤ú Í∞ëÏò∑ÏûÖÎãàÎã§.' },
            { id: 44, type: ItemType.ARMOR, name: 'ÏÇ¨Ïä¨ Í∞ëÏò∑', price: 300, grade: ItemGrade.UNCOMMON, defense: 8, description: 'ÏûëÏùÄ Í≥†Î¶¨Î•º ÏóÆÏñ¥ ÎßåÎì† Í∞ëÏò∑ÏûÖÎãàÎã§.' },
            { id: 45, type: ItemType.ARMOR, name: 'ÌîåÎ†àÏù¥Ìä∏ ÏïÑÎ®∏', price: 1500, grade: ItemGrade.RARE, defense: 20, description: 'Ï†ÑÏã†ÏùÑ Í∞êÏã∏Îäî ÌåêÍ∏à Í∞ëÏò∑ÏûÖÎãàÎã§.' },
            { id: 46, type: ItemType.ARMOR, name: 'Í∏∞ÏÇ¨Ïùò Í∞ëÏò∑', price: 3000, grade: ItemGrade.EPIC, defense: 35, description: 'Í≥†ÏúÑ Í∏∞ÏÇ¨Îì§Ïù¥ ÏûÖÎäî Í≤¨Í≥†Ìïú Í∞ëÏò∑ÏûÖÎãàÎã§.' },
            { id: 47, type: ItemType.ARMOR, name: 'Ïö©ÎπÑÎäò Í∞ëÏò∑', price: 7500, grade: ItemGrade.LEGENDARY, defense: 50, description: 'Ïö©Ïùò ÎπÑÎäòÎ°ú ÎßåÎì§Ïñ¥Ï†∏ ÎßàÎ≤ïÍ≥º ÌôîÏóºÏóê Í∞ïÌïú Ï†ÄÌï≠Î†•ÏùÑ Í∞ÄÏßëÎãàÎã§.' },

            // --- Ïã†Í∑ú ÏÜåÎ™®Ìíà ---
            { id: 50, type: ItemType.CONSUMABLE, name: 'Ï§ëÍ∏â Ï≤¥Î†• Î¨ºÏïΩ', price: 50, grade: ItemGrade.UNCOMMON, effect: { type: 'heal', amount: 50 }, description: 'HPÎ•º 50 ÌöåÎ≥µÌï©ÎãàÎã§.' },
            { id: 51, type: ItemType.CONSUMABLE, name: 'ÏÉÅÍ∏â Ï≤¥Î†• Î¨ºÏïΩ', price: 120, grade: ItemGrade.RARE, effect: { type: 'heal', amount: 150 }, description: 'HPÎ•º 150 ÌöåÎ≥µÌï©ÎãàÎã§.' },
            { id: 52, type: ItemType.CONSUMABLE, name: 'ÎèÖÍ∑πÎ¨º Î≥ë', price: 80, grade: ItemGrade.UNCOMMON, effect: { type: 'damage_enemy', amount: 30 }, description: 'Ï†ÅÏóêÍ≤å 30Ïùò ÎèÖ ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            { id: 53, type: ItemType.CONSUMABLE, name: 'ÌôîÏóºÎ≥ë', price: 150, grade: ItemGrade.RARE, effect: { type: 'damage_enemy', amount: 70 }, description: 'Ï†ÅÏóêÍ≤å 70Ïùò ÌôîÏóº ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            { id: 54, type: ItemType.CONSUMABLE, name: 'Ïã†ÏÑ±Ìïú ÏÑ±Ïàò', price: 300, grade: ItemGrade.EPIC, effect: { type: 'damage_enemy', amount: 150 }, description: 'Ïñ∏Îç∞ÎìúÏóêÍ≤å ÌäπÌûà Í∞ïÎ†•Ìïú Ïã†ÏÑ±Ìïú ÌîºÌï¥Î•º 150 ÏûÖÌûôÎãàÎã§.' },
            
            // --- Ïã†Í∑ú Ï¥ùÍ∏∞Î•ò ---
            { id: 55, type: ItemType.WEAPON, name: 'ÎÇ°ÏùÄ Í∂åÏ¥ù', price: 85, grade: ItemGrade.COMMON, damage: 6, accuracy: 0.95, weaponType: 'Gun', description: 'Í∏∞Î≥∏Ï†ÅÏù∏ Î∞òÏûêÎèô Í∂åÏ¥ùÏûÖÎãàÎã§.' },
            { id: 56, type: ItemType.WEAPON, name: 'ÌéåÌîÑ Ïï°ÏÖò ÏÉ∑Í±¥', price: 420, grade: ItemGrade.UNCOMMON, damage: 15, accuracy: 0.75, weaponType: 'Gun', description: 'Í∑ºÍ±∞Î¶¨ÏóêÏÑú Í∞ïÎ†•Ìïú ÏúÑÎ†•ÏùÑ Î∞úÌúòÌïòÎäî ÏÇ∞ÌÉÑÏ¥ùÏûÖÎãàÎã§.' },
            { id: 57, type: ItemType.WEAPON, name: 'Í∏∞Í¥ÄÎã®Ï¥ù', price: 480, grade: ItemGrade.UNCOMMON, damage: 9, accuracy: 0.9, weaponType: 'Gun', procChance: 0.15, procDamage: 4, description: 'Îπ†Î•∏ Ïó∞ÏÇ¨Î†•ÏùÑ ÏûêÎûëÌï©ÎãàÎã§. 15% ÌôïÎ•†Î°ú Ï∂îÍ∞Ä ÏÇ¨Í≤©ÏùÑ Ìï©ÎãàÎã§.' },
            { id: 58, type: ItemType.WEAPON, name: 'ÎèåÍ≤©ÏÜåÏ¥ù', price: 1580, grade: ItemGrade.RARE, damage: 19, accuracy: 0.9, weaponType: 'Gun', description: 'ÏïàÏ†ïÏ†ÅÏù¥Í≥† Í∑†Ìòï Ïû°Ìûå ÏûêÎèôÏÜåÏ¥ùÏûÖÎãàÎã§.' },
            { id: 59, type: ItemType.WEAPON, name: 'AWP Ï†ÄÍ≤©ÏÜåÏ¥ù', price: 4000, grade: ItemGrade.EPIC, damage: 35, accuracy: 0.9, weaponType: 'Gun', critChance: 0.3, critDamageMultiplier: 2.5, description: 'Ìïú Î∞úÏóê Î™®Îì† Í≤ÉÏùÑ Í±∞Îäî Í∞ïÎ†•Ìïú Ï†ÄÍ≤©ÏÜåÏ¥ù. ÏπòÎ™ÖÌÉÄ ÌôïÎ•†Ïù¥ Îß§Ïö∞ ÎÜíÏäµÎãàÎã§.' },
            { id: 60, type: ItemType.WEAPON, name: 'Í≤ΩÍ∏∞Í¥ÄÏ¥ù', price: 3900, grade: ItemGrade.EPIC, damage: 28, accuracy: 0.8, weaponType: 'Gun', description: 'Î¨µÏßÅÌïú ÌôîÎ†•ÏúºÎ°ú Ï†ÅÏùÑ Ï†úÏïïÌïòÎäî Í∏∞Í¥ÄÏ¥ùÏûÖÎãàÎã§.' },
            { id: 61, type: ItemType.WEAPON, name: 'ÎØ∏ÎãàÍ±¥', price: 23000, grade: ItemGrade.LEGENDARY, damage: 58, accuracy: 0.75, weaponType: 'Gun', procChance: 0.4, procDamage: 15, description: 'Î∂ÑÎãπ ÏàòÏ≤ú Î∞úÏùò ÌÉÑÌôòÏùÑ ÏèüÏïÑÎ∂ìÎäî ÌååÍ¥¥Ïùò ÌôîÏã†. 40% ÌôïÎ•†Î°ú Ï∂îÍ∞Ä ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            { id: 62, type: ItemType.WEAPON, name: 'Ìô©Í∏à Ï¥ù', price: 30000, grade: ItemGrade.LEGENDARY, damage: 77, accuracy: 1.0, weaponType: 'Gun', critChance: 0.5, critDamageMultiplier: 3.0, description: 'Î™®Îì† Í≤ÉÏùÑ Ìïú Î∞©Ïóê ÎÅùÎÇ¥Îäî Ï†ÑÏÑ§Ïùò Ìô©Í∏à Ï¥ù. Î™ÖÏ§ëÎ•†Í≥º ÏπòÎ™ÖÌÉÄÏú®Ïù¥ Í≤ΩÏù¥Î°≠ÏäµÎãàÎã§.' },
            { id: 63, type: ItemType.WEAPON, name: 'Ïã¨ÌåêÏûêÏùò Ï≤†Ìá¥', price: 24500, grade: ItemGrade.LEGENDARY, damage: 70, accuracy: 0.9, critChance: 0.1, critDamageMultiplier: 2.0, procChance: 0.2, procDamage: 110, description: 'Ï†ÅÏùÑ Ïã¨ÌåêÌïòÎäî Ïú°Ï§ëÌïú Ï≤†Ìá¥. 20% ÌôïÎ•†Î°ú Ï†ïÏùòÏùò ÌûòÏù¥ Î∞úÎèôÌïòÏó¨ 110Ïùò Ï∂îÍ∞Ä Ïã†ÏÑ± ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
            
            // --- Ï∂îÍ∞Ä Î∞©Ïñ¥Íµ¨ & ÏÜåÎ™®Ìíà ---
            { id: 64, type: ItemType.ARMOR, name: 'ÎØ∏Ïä§Î¶¥ ÏÖîÏ∏†', price: 900, grade: ItemGrade.RARE, defense: 18, description: 'Í∞ÄÎ≥çÍ≥† ÌäºÌäºÌïú ÎØ∏Ïä§Î¶¥Î°ú Ïß† ÏÖîÏ∏†ÏûÖÎãàÎã§.' },
            { id: 65, type: ItemType.ARMOR, name: 'Í∑∏Î¶ºÏûê Î°úÎ∏å', price: 2800, grade: ItemGrade.EPIC, defense: 32, description: 'Ïñ¥Îë†Ïóê Î™∏ÏùÑ Ïà®Í∏∞Í∏∞ Ï¢ãÏùÄ Î°úÎ∏å. ÏïΩÍ∞ÑÏùò ÎßàÎ≤ï Ï†ÄÌï≠Î†•ÎèÑ ÏûàÏäµÎãàÎã§.' },
            { id: 66, type: ItemType.ARMOR, name: 'ÏàòÌò∏ÏûêÏùò Í∞ëÏò∑', price: 7000, grade: ItemGrade.LEGENDARY, defense: 48, description: 'Í≥†ÎåÄ ÏàòÌò∏ÏûêÎì§Ïùò ÌûòÏù¥ ÍπÉÎì† Í∞ëÏò∑ÏûÖÎãàÎã§.' },
            { id: 67, type: ItemType.CONSUMABLE, name: 'ÏµúÏÉÅÍ∏â Ï≤¥Î†• Î¨ºÏïΩ', price: 250, grade: ItemGrade.EPIC, effect: { type: 'heal', amount: 300 }, description: 'HPÎ•º 300 ÌöåÎ≥µÌï©ÎãàÎã§.' },
            { id: 68, type: ItemType.CONSUMABLE, name: 'ÏóòÎ¶≠ÏÑú', price: 1000, grade: ItemGrade.LEGENDARY, effect: { type: 'heal', amount: 9999 }, description: 'HPÎ•º ÏôÑÏ†ÑÌûà ÌöåÎ≥µÏãúÌÇµÎãàÎã§.' },
            { id: 69, type: ItemType.CONSUMABLE, name: 'Í∞ïÎ†•Ìïú ÌôîÏóºÎ≥ë', price: 400, grade: ItemGrade.EPIC, effect: { type: 'damage_enemy', amount: 120 }, description: 'Ï†ÅÏóêÍ≤å 120Ïùò Í∞ïÎ†•Ìïú ÌôîÏóº ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
        ];

        const allMaterials = [
            { id: 6, name: 'Ï≤†Í¥ëÏÑù', description: 'Í∞ïÏ≤†ÏùÑ ÎßåÎìúÎäî Îç∞ ÏÇ¨Ïö©ÎêòÎäî Í∏∞Î≥∏Ï†ÅÏù∏ Í¥ëÎ¨ºÏûÖÎãàÎã§.' },
            { id: 7, name: 'Í∞ÄÏ£Ω', description: 'ÎèôÎ¨ºÏóêÍ≤åÏÑú ÏñªÏùÑ Ïàò ÏûàÎäî ÏßàÍ∏¥ Í∞ÄÏ£ΩÏûÖÎãàÎã§.' },
            { id: 12, name: 'ÎßàÎ†•Ïùò Îèå', description: 'Ïã†ÎπÑÌïú ÎßàÎ†•Ïù¥ ÍπÉÎì† Îèå. Í∞ïÌôîÏóê ÏÇ¨Ïö©Îê©ÎãàÎã§.' },
        ];

        const allRecipes = [
            { id: 1, name: 'Í∞ïÏ≤† Í≤Ä Ï†úÏûë', result: allItems.find(item => item.id === 3), materials: [{ materialId: 6, quantity: 5 }], requiredCraftingLevel: 1 },
            { id: 2, name: 'Í∞ÄÏ£Ω Í∞ëÏò∑ Ï†úÏûë', result: allItems.find(item => item.id === 4), materials: [{ materialId: 7, quantity: 10 }], requiredCraftingLevel: 1 },
        ];

        const allMonsters = [
            { id: 1, name: 'Ïä¨ÎùºÏûÑ', hp: 20, maxHp: 20, attack: 5, defense: 0, xp: 5, gold: 10, drops: [{ itemId: 7, chance: 0.1, quantity: 1 }], emoji: 'ü¶†' },
            { id: 2, name: 'Í≥†Î∏îÎ¶∞', hp: 30, maxHp: 30, attack: 6, defense: 2, xp: 10, gold: 20, drops: [{ itemId: 2, chance: 0.05, quantity: 1 }], emoji: 'üë∫' },
            { id: 3, name: 'Ïò§ÌÅ¨', hp: 45, maxHp: 45, attack: 8, defense: 3, xp: 20, gold: 40, drops: [{ itemId: 3, chance: 0.02, quantity: 1 }], emoji: 'üëπ' },
            { id: 4, name: 'ÎçòÏ†Ñ Í∞ÄÎîîÏñ∏', hp: 130, maxHp: 130, attack: 18, defense: 7, xp: 100, gold: 200, drops: [{ itemId: 12, chance: 0.5, quantity: 2 }], emoji: 'ü§ñ' },
            { id: 101, name: 'Ìï¥Í≥® Í∏∞ÏÇ¨', hp: 60, maxHp: 60, attack: 12, defense: 8, xp: 30, gold: 60, drops: [{ itemId: 9, chance: 0.05, quantity: 1 }], emoji: 'üíÄ' },
            { id: 102, name: 'Ïò§Ïö∞Í±∞', hp: 80, maxHp: 80, attack: 15, defense: 5, xp: 50, gold: 100, drops: [{ itemId: 27, chance: 0.03, quantity: 1 }], emoji: 'ü¶ç' },
            { id: 103, name: 'Î¶¨Ïπò', hp: 100, maxHp: 100, attack: 20, defense: 10, xp: 80, gold: 150, drops: [{ itemId: 34, chance: 0.02, quantity: 1 }], emoji: 'üßô' },
            { id: 104, name: 'ÏÉàÎÅºÏö©', hp: 250, maxHp: 250, attack: 28, defense: 18, xp: 300, gold: 500, drops: [{ itemId: 47, chance: 0.1, quantity: 1 }], emoji: 'üêâ' },
        ];

        const allDungeons = [
            { id: 0, name: 'Ïä¨ÎùºÏûÑ Íµ¥', description: 'Í∞ÄÏû• ÏïΩÌïú Ïä¨ÎùºÏûÑÎì§Ïù¥ Î™®Ïó¨ÏûàÎäî ÎèôÍµ¥ÏûÖÎãàÎã§. Î™®ÌóòÏùò Ï≤´Í±∏ÏùåÏúºÎ°ú ÏïàÏÑ±ÎßûÏ∂§ÏûÖÎãàÎã§.', difficulty: 1, stages: 10, monsters: [1, 1, 1, 1, 2, 1, 1, 2, 1, 2], rewards: { xp: 150, gold: 250, items: [{ itemId: 7, quantity: 5 }] } },
            { id: 1, name: 'Í≥†Î∏îÎ¶∞ ÎèôÍµ¥', description: 'Ï¥àÎ≥¥ Î™®ÌóòÍ∞ÄÏóêÍ≤å Ï†ÅÌï©Ìïú ÎèôÍµ¥ÏûÖÎãàÎã§. Í≥†Î∏îÎ¶∞Îì§Ïù¥ ÏÑúÏãùÌïòÍ≥† ÏûàÏäµÎãàÎã§.', difficulty: 2, stages: 10, monsters: [2, 2, 2, 3, 2, 3, 2, 3, 3, 3], rewards: { xp: 500, gold: 1000, items: [{ itemId: 12, quantity: 3 }] } },
            { id: 2, name: 'Ïò§ÌÅ¨Ïùò Ï†ÑÏ¥àÍ∏∞ÏßÄ', description: 'Í∞ïÎ†•Ìïú Ïò§ÌÅ¨Îì§Ïù¥ ÏßÄÌÇ§Í≥† ÏûàÎäî Ï†ÑÏ¥àÍ∏∞ÏßÄÏûÖÎãàÎã§. Îã®Îã®Ìûà Ï§ÄÎπÑÌï¥Ïïº Ìï©ÎãàÎã§.', difficulty: 3, stages: 10, monsters: [3, 3, 3, 3, 3, 4, 3, 4, 3, 4], rewards: { xp: 2500, gold: 5000, items: [{ itemId: 8, quantity: 1 }, { itemId: 12, quantity: 10 }] } },
            { id: 3, name: 'ÏûäÌòÄÏßÑ ÏßÄÌïòÎ¨òÏßÄ', description: 'Ïñ∏Îç∞ÎìúÎì§Ïù¥ Î∞∞ÌöåÌïòÎäî ÏúÑÌóòÌïú ÏßÄÌïòÎ¨òÏßÄÏûÖÎãàÎã§. Í∞ïÎ†•Ìïú Ìï¥Í≥® Í∏∞ÏÇ¨ÏôÄ Ïò§Ïö∞Í±∞Í∞Ä Îì±Ïû•Ìï©ÎãàÎã§.', difficulty: 4, stages: 10, monsters: [3, 101, 3, 101, 4, 101, 102, 101, 4, 102], rewards: { xp: 5000, gold: 10000, items: [{ itemId: 46, quantity: 1 }, { itemId: 12, quantity: 20 }] } },
            { id: 4, name: 'Ïö©Ïùò Îë•ÏßÄ', description: 'Ï†ÑÏÑ§ ÏÜç Ïö©Ïù¥ Ïû†Îì§Ïñ¥ ÏûàÎã§Îäî Îë•ÏßÄ. Í∞ïÎ†•Ìïú Î™¨Ïä§ÌÑ∞Îì§Í≥º Î¶¨Ïπò, Í∑∏Î¶¨Í≥†... ÏÉàÎÅºÏö©Ïù¥ ÎãπÏã†ÏùÑ Í∏∞Îã§Î¶ΩÎãàÎã§.', difficulty: 5, stages: 10, monsters: [102, 4, 102, 103, 4, 103, 102, 103, 103, 104], rewards: { xp: 12000, gold: 30000, items: [{ itemId: 38, quantity: 1 }] } },
        ];

        const allQuests = [
            {
                id: 1,
                title: 'Ï¥àÎ≥¥ ÏÇ¨ÎÉ•Íæº',
                description: 'Ïä¨ÎùºÏûÑÏùÑ 5ÎßàÎ¶¨ Ï≤òÏπòÌïòÏÑ∏Ïöî.',
                type: 'DEFEAT_MONSTER',
                targetId: 1, // Slime ID
                targetQuantity: 5,
                rewards: { xp: 50, gold: 100 }
            },
            {
                id: 2,
                title: 'Í∞ÄÏ£Ω ÏàòÏßë',
                description: 'Í∞ÄÏ£ΩÏùÑ 10Í∞ú Î™®ÏúºÏÑ∏Ïöî.',
                type: 'COLLECT_ITEM',
                targetId: 7, // Leather ID
                targetQuantity: 10,
                rewards: { xp: 30, gold: 150 }
            },
            {
                id: 3,
                title: 'Ï≤´ Î≤àÏß∏ Ï†úÏûë',
                description: 'Í∞ïÏ≤† Í≤ÄÏùÑ 1Í∞ú Ï†úÏûëÌïòÏÑ∏Ïöî.',
                type: 'CRAFT_ITEM',
                targetId: 3, // Steel Sword ID
                targetQuantity: 1,
                rewards: { xp: 100, gold: 200, items: [{ itemId: 12, quantity: 2 }] } // Magic Stone reward
            }
        ];

        const townLevels = [
            { name: "ÌèêÌóà", xpRequired: 0, costToUpgrade: 1000 },
            { name: "ÏûëÏùÄ ÎßàÏùÑ", xpRequired: 100, costToUpgrade: 3000 },
            { name: "ÎèÑÏãú", xpRequired: 500, costToUpgrade: 12000 },
            { name: "ÏÑ±", xpRequired: 2000, costToUpgrade: 50000 },
            { name: "ÏôïÍµ≠", xpRequired: 10000, costToUpgrade: Infinity },
        ];

        const trophyRoadMilestones = [
            { trophies: 100, rewards: { gold: 500 } },
            { trophies: 250, rewards: { items: [{ itemId: 12, quantity: 5 }] } },
            { trophies: 500, rewards: { gold: 2000, items: [{ itemId: 9, quantity: 1 }] } },
            { trophies: 1000, rewards: { gold: 10000, items: [{ itemId: 10, quantity: 1 }] } },
        ];

        const getInitialPlayerStats = () => ({
            playerName: 'Î™®ÌóòÍ∞Ä',
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            maxHp: 50,
            hp: 50,
            attack: 5,
            defense: 2,
            gold: 100,
            craftingLevel: 1,
            craftingXp: 0,
            craftingXpToNextLevel: 50,
            trophies: 0,
            claimedTrophyRewards: [],
            inventory: [{ ...allItems.find(i => i.id === 1), quantity: 1 }],
            equipment: {
                weapon: allItems.find(i => i.id === 1),
                armor: null,
            },
            playerClass: null,
            townLevel: 1,
            townXp: 0,
            activeQuests: [],
            pets: [],
            activePetId: null,
        });

        // --- UTILITY FUNCTIONS ---
        const formatNumber = (num) => num.toLocaleString();

        const getDisplayName = (item) => {
            if (!item) return 'ÏóÜÏùå';
            if (item.enhancementLevel && item.enhancementLevel > 0) {
                return `+${item.enhancementLevel} ${item.name}`;
            }
            return item.name;
        };

        // --- COMPONENTS ---

        const StatBar = ({ value, maxValue, color, label }) => (
            <div className="stat-bar-container">
                <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '2px', fontSize: '0.9em' }}>
                    <span>{label}</span>
                    <span>{formatNumber(value)} / {formatNumber(maxValue)}</span>
                </div>
                <div className="stat-bar">
                    <div className="stat-bar-fill" style={{ width: `${(value / maxValue) * 100}%`, backgroundColor: color }}></div>
                </div>
            </div>
        );

        const PlayerStatsView = ({ playerStats, setPlayerStats, setView }) => {
            const [isEditingName, setIsEditingName] = useState(false);
            const [newName, setNewName] = useState(playerStats.playerName);

            const handleNameChange = () => {
                if (newName.trim() !== "") {
                    setPlayerStats(prev => ({ ...prev, playerName: newName.trim() }));
                    setIsEditingName(false);
                }
            };

            const totalAttack = useMemo(() => {
                const weaponDamage = playerStats.equipment.weapon?.damage || 0;
                const enhancementBonus = playerStats.equipment.weapon?.enhancementLevel || 0;
                const petBonus = playerStats.activePetId ? playerStats.pets.find(p => p.id === playerStats.activePetId)?.attackBonus || 0 : 0;
                return playerStats.attack + weaponDamage + (enhancementBonus * 2) + petBonus;
            }, [playerStats]);

            const totalDefense = useMemo(() => {
                const armorDefense = playerStats.equipment.armor?.defense || 0;
                const enhancementBonus = playerStats.equipment.armor?.enhancementLevel || 0;
                const petBonus = playerStats.activePetId ? playerStats.pets.find(p => p.id === playerStats.activePetId)?.defenseBonus || 0 : 0;
                return playerStats.defense + armorDefense + enhancementBonus + petBonus;
            }, [playerStats]);

            return (
                <div className="card">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <div style={{display: 'flex', alignItems: 'center', gap: '10px'}}>
                         {isEditingName ? (
                            <input 
                                type="text" 
                                value={newName} 
                                onChange={(e) => setNewName(e.target.value)} 
                                onBlur={handleNameChange}
                                onKeyDown={(e) => e.key === 'Enter' && handleNameChange()}
                                autoFocus
                            />
                        ) : (
                            <h2>
                                {playerStats.playerName}
                                <button className="edit-name-btn" onClick={() => setIsEditingName(true)}>‚úèÔ∏è</button>
                            </h2>
                        )}
                    </div>
                    <p>Î†àÎ≤®: {playerStats.level} ({playerStats.playerClass ? PlayerClasses[playerStats.playerClass].name : "Î™®ÌóòÍ∞Ä"})</p>
                    <StatBar value={playerStats.hp} maxValue={playerStats.maxHp} color="#4caf50" label="HP" />
                    <StatBar value={playerStats.xp} maxValue={playerStats.xpToNextLevel} color="#2196f3" label="XP" />
                    <p>Í≥µÍ≤©Î†•: {totalAttack}</p>
                    <p>Î∞©Ïñ¥Î†•: {totalDefense}</p>
                    <p>Í≥®Îìú: {formatNumber(playerStats.gold)} G</p>
                    <p>Ìä∏Î°úÌîº: {formatNumber(playerStats.trophies)} üèÜ</p>
                    <h3>Ïû•ÎπÑ</h3>
                    <p>Î¨¥Í∏∞: <span className={playerStats.equipment.weapon ? ItemGradeInfo[playerStats.equipment.weapon.grade]?.class : ''}>{getDisplayName(playerStats.equipment.weapon)}</span></p>
                    <p>Í∞ëÏò∑: <span className={playerStats.equipment.armor ? ItemGradeInfo[playerStats.equipment.armor.grade]?.class : ''}>{getDisplayName(playerStats.equipment.armor)}</span></p>
                    
                    <InventoryView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />
                </div>
            );
        };

        const TownView = ({ playerStats, setView }) => (
            <div className="card town-layout">
                <h2>ÎßàÏùÑ</h2>
                <p>ÌôòÏû•RPGÏóê Ïò§Ïã† Í≤ÉÏùÑ ÌôòÏòÅÌï©ÎãàÎã§! Î¨¥ÏóáÏùÑ ÌïòÏãúÍ≤†ÏäµÎãàÍπå?</p>
                <div className="town-grid">
                    <button onClick={() => setView(View.PLAYER)}>ÎÇ¥ Ï†ïÎ≥¥</button>
                    <button onClick={() => setView(View.SHOP)}>ÏÉÅÏ†ê</button>
                    <button onClick={() => setView(View.BLACKSMITH)}>ÎåÄÏû•Í∞Ñ</button>
                    <button onClick={() => setView(View.QUEST_BOARD)}>ÌÄòÏä§Ìä∏</button>
                    <button onClick={() => {
                        if (playerStats.level < 10) {
                            alert('ÏßÅÏóÖ ÏÑ†ÌÉùÏùÄ 10Î†àÎ≤®Î∂ÄÌÑ∞ Í∞ÄÎä•Ìï©ÎãàÎã§.');
                        } else {
                            setView(View.CLASS_SELECTION);
                        }
                    }}>ÏßÅÏóÖ</button>
                    <button onClick={() => setView(View.GACHA_SHRINE)}>ÎΩëÍ∏∞ ÏÑ±ÏÜå</button>
                    <button onClick={() => setView(View.TOWN_HALL)}>ÎßàÏùÑ ÌöåÍ¥Ä</button>
                    <button onClick={() => setView(View.TROPHY_ROAD)}>Ìä∏Î°úÌîº Î°úÎìú</button>
                    <button onClick={() => setView(View.PETS)}>Î∞òÎ†§ÎèôÎ¨º</button>
                </div>
                <div className="town-main-actions">
                    <button onClick={() => setView(View.BATTLE)}>Ï†ÑÌà¨ ÏãúÏûë</button>
                    <button onClick={() => setView(View.DUNGEON)}>ÎçòÏ†Ñ</button>
                </div>
            </div>
        );

        const ShopView = ({ playerStats, setPlayerStats, setView }) => {
            const [selectedItem, setSelectedItem] = useState(null);
            const [shopTab, setShopTab] = useState('Weapons');
            
            const sortedShopItems = useMemo(() => {
                return [...allItems]
                    .filter(item => item.type !== ItemType.MATERIAL)
                    .sort((a, b) => {
                        const gradeOrderA = ItemGradeInfo[a.grade]?.order || 0;
                        const gradeOrderB = ItemGradeInfo[b.grade]?.order || 0;
                        if (gradeOrderA !== gradeOrderB) {
                            return gradeOrderA - gradeOrderB;
                        }
                        return a.price - b.price;
                    });
            }, []);


            const handleBuy = () => {
                if (selectedItem && playerStats.gold >= selectedItem.price) {
                    setPlayerStats(prev => {
                        const newInventory = [...prev.inventory];
                        const existingItem = newInventory.find(i => i.id === selectedItem.id && !(i.enhancementLevel > 0)); // Only stack non-enhanced items
                        if (existingItem) {
                            existingItem.quantity += 1;
                        } else {
                            newInventory.push({ ...selectedItem, quantity: 1 });
                        }
                        return {
                            ...prev,
                            gold: prev.gold - selectedItem.price,
                            inventory: newInventory
                        };
                    });
                    alert(`${selectedItem.name}ÏùÑ(Î•º) Íµ¨Îß§ÌñàÏäµÎãàÎã§!`);
                } else {
                    alert('Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.');
                }
            };

            const itemsToDisplay = sortedShopItems.filter(item => {
                if (shopTab === 'Weapons') return item.type === ItemType.WEAPON;
                if (shopTab === 'Armor') return item.type === ItemType.ARMOR;
                if (shopTab === 'Consumables') return item.type === ItemType.CONSUMABLE;
                return false;
            });

            return (
                <div className="card">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>ÏÉÅÏ†ê</h2>
                     <div className="shop-tabs">
                        <button className={shopTab === 'Weapons' ? 'active' : ''} onClick={() => setShopTab('Weapons')}>Î¨¥Í∏∞</button>
                        <button className={shopTab === 'Armor' ? 'active' : ''} onClick={() => setShopTab('Armor')}>Î∞©Ïñ¥Íµ¨</button>
                        <button className={shopTab === 'Consumables' ? 'active' : ''} onClick={() => setShopTab('Consumables')}>ÏÜåÎ™®Ìíà</button>
                    </div>
                    <div className="shop-grid">
                        {itemsToDisplay.map(item => (
                            <div
                                key={item.id}
                                className={`item-card ${selectedItem?.id === item.id ? 'selected' : ''}`}
                                onClick={() => setSelectedItem(item)}
                            >
                                <strong className={ItemGradeInfo[item.grade]?.class}>{getDisplayName(item)}</strong>
                                <p>{item.price} G</p>
                            </div>
                        ))}
                    </div>
                    {selectedItem && (
                        <div className="card" style={{ marginTop: '20px' }}>
                            <h3>{getDisplayName(selectedItem)} <span className={ItemGradeInfo[selectedItem.grade]?.class}>({ItemGradeInfo[selectedItem.grade]?.name})</span></h3>
                            <p>{selectedItem.description}</p>
                            {selectedItem.damage && <p>Í≥µÍ≤©Î†•: {selectedItem.damage}</p>}
                            {selectedItem.defense && <p>Î∞©Ïñ¥Î†•: {selectedItem.defense}</p>}
                            {selectedItem.critChance && <p>ÏπòÎ™ÖÌÉÄ ÌôïÎ•†: {selectedItem.critChance * 100}%</p>}
                            <p>Í∞ÄÍ≤©: {selectedItem.price} G</p>
                            <button onClick={handleBuy} disabled={playerStats.gold < selectedItem.price}>Íµ¨Îß§</button>
                        </div>
                    )}
                </div>
            );
        };

        const InventoryView = ({ playerStats, setPlayerStats }) => {

            const handleEquip = (itemToEquip) => {
                setPlayerStats(prev => {
                    const newEquipment = { ...prev.equipment };
                    let newInventory = [...prev.inventory];
                    let previouslyEquipped = null;

                    if (itemToEquip.type === ItemType.WEAPON) {
                        previouslyEquipped = newEquipment.weapon;
                        newEquipment.weapon = itemToEquip;
                    } else if (itemToEquip.type === ItemType.ARMOR) {
                        previouslyEquipped = newEquipment.armor;
                        newEquipment.armor = itemToEquip;
                    }

                    // Remove equipped item from inventory
                    const itemInInventory = newInventory.find(i => i.id === itemToEquip.id && i.enhancementLevel === itemToEquip.enhancementLevel);
                    if (itemInInventory.quantity > 1) {
                        itemInInventory.quantity -= 1;
                    } else {
                        newInventory = newInventory.filter(i => i !== itemInInventory);
                    }

                    // Add previously equipped item back to inventory
                    if (previouslyEquipped) {
                         const existingItem = newInventory.find(i => i.id === previouslyEquipped.id && i.enhancementLevel === previouslyEquipped.enhancementLevel);
                        if (existingItem) {
                            existingItem.quantity += 1;
                        } else {
                            newInventory.push({ ...previouslyEquipped, quantity: 1 });
                        }
                    }

                    return { ...prev, equipment: newEquipment, inventory: newInventory };
                });
            };
            
             const handleUse = (itemToUse) => {
                if (itemToUse.type === ItemType.CONSUMABLE && itemToUse.effect?.type === 'heal') {
                    setPlayerStats(prev => {
                        const newHp = Math.min(prev.maxHp, prev.hp + itemToUse.effect.amount);
                        const newInventory = prev.inventory.map(item =>
                            item.id === itemToUse.id ? { ...item, quantity: item.quantity - 1 } : item
                        ).filter(item => item.quantity > 0);
                        
                        return { ...prev, hp: newHp, inventory: newInventory };
                    });
                }
            };
            
            return (
                <div className="card" style={{marginTop: '20px'}}>
                    <h3>Ïù∏Î≤§ÌÜ†Î¶¨</h3>
                    <div className="inventory-list">
                        {playerStats.inventory.length > 0 ? playerStats.inventory.map((item, index) => (
                            <div key={`${item.id}-${index}-${item.enhancementLevel || 0}`} className="inventory-item">
                                <span><strong className={ItemGradeInfo[item.grade]?.class}>{getDisplayName(item)}</strong> (x{item.quantity})</span>
                                <div>
                                     {item.type === ItemType.WEAPON || item.type === ItemType.ARMOR ? (
                                        <button onClick={() => handleEquip(item)}>Ïû•Ï∞©</button>
                                    ) : null}
                                    {item.type === ItemType.CONSUMABLE ? (
                                        <button onClick={() => handleUse(item)}>ÏÇ¨Ïö©</button>
                                    ): null}
                                </div>
                            </div>
                        )) : <p>Ïù∏Î≤§ÌÜ†Î¶¨Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.</p>}
                    </div>
                </div>
            );
        };

        const BattleView = ({ playerStats, setPlayerStats, setView }) => {
            const [monster, setMonster] = useState(null);
            const [battleLog, setBattleLog] = useState([]);
            const [isPlayerTurn, setIsPlayerTurn] = useState(true);
            const [isBattleOver, setIsBattleOver] = useState(false);
            const [damagePopups, setDamagePopups] = useState([]);
            const [playerAttacking, setPlayerAttacking] = useState(false);
            const [enemyAttacking, setEnemyAttacking] = useState(false);
            const [ultimateCharge, setUltimateCharge] = useState(0);
            const [showInventory, setShowInventory] = useState(false);
            
            const addDamagePopup = useCallback((amount, isCrit, target) => {
                const id = Date.now() + Math.random();
                setDamagePopups(prev => [...prev, { id, amount, isCrit, target }]);
                setTimeout(() => {
                    setDamagePopups(prev => prev.filter(p => p.id !== id));
                }, 600);
            }, []);

            const addLog = useCallback((message, type, petSkill = false) => {
              const className = petSkill ? 'pet-skill-message' : type;
              setBattleLog(prev => [...prev, <p key={prev.length} className={className}>{message}</p>]);
            }, []);

            const totalAttack = useMemo(() => {
                const weapon = playerStats.equipment.weapon;
                const weaponDamage = weapon?.damage || 0;
                const enhancementBonus = weapon?.enhancementLevel || 0;
                const petBonus = playerStats.activePetId ? playerStats.pets.find(p => p.id === playerStats.activePetId)?.attackBonus || 0 : 0;
                return playerStats.attack + weaponDamage + (enhancementBonus * 2) + petBonus;
            }, [playerStats]);

            const totalDefense = useMemo(() => {
                const armor = playerStats.equipment.armor;
                const armorDefense = armor?.defense || 0;
                const enhancementBonus = armor?.enhancementLevel || 0;
                const petBonus = playerStats.activePetId ? playerStats.pets.find(p => p.id === playerStats.activePetId)?.defenseBonus || 0 : 0;
                return playerStats.defense + armorDefense + enhancementBonus + petBonus;
            }, [playerStats]);
            
            const activePet = useMemo(() => playerStats.activePetId ? playerStats.pets.find(p => p.id === playerStats.activePetId) : null, [playerStats.activePetId, playerStats.pets]);

            const playerConsumables = useMemo(() => 
                playerStats.inventory.filter(i => i.type === ItemType.CONSUMABLE), 
                [playerStats.inventory]
            );

            useEffect(() => {
                const getBattleMonster = () => {
                    const weapon = playerStats.equipment.weapon;
                    const threatLevel = (weapon?.damage || 0) + (weapon?.price / 200 || 0) + playerStats.level;
                    
                    let possibleMonsters;

                    if (threatLevel < 25) { // Early game
                        possibleMonsters = allMonsters.filter(m => [1, 2].includes(m.id)); // Slime, Goblin
                    } else if (threatLevel < 50) { // Mid game
                        possibleMonsters = allMonsters.filter(m => [2, 3].includes(m.id)); // Goblin, Orc
                    } else if (threatLevel < 80) { // Late mid game
                        possibleMonsters = allMonsters.filter(m => [3, 101].includes(m.id)); // Orc, Skeleton Knight
                    } else if (threatLevel < 120) { // High level
                        possibleMonsters = allMonsters.filter(m => [101, 102, 4].includes(m.id)); // Skeleton Knight, Ogre, Dungeon Guardian
                    } else { // End game
                        possibleMonsters = allMonsters.filter(m => [102, 103, 4].includes(m.id)); // Ogre, Lich, Dungeon Guardian
                    }
                    
                    if (!possibleMonsters || possibleMonsters.length === 0) {
                        possibleMonsters = allMonsters.filter(m => m.id === 1); // fallback
                    }
                    
                    return { ...possibleMonsters[Math.floor(Math.random() * possibleMonsters.length)] };
                };
                
                const randomMonster = getBattleMonster();
                setMonster(randomMonster);
                addLog(`${randomMonster.name}Ïù¥(Í∞Ä) ÎÇòÌÉÄÎÇ¨Îã§!`, 'system-message');
            }, [addLog, playerStats]);

            const handleBattleEnd = useCallback((win) => {
                setIsBattleOver(true);
                if (win && monster) {
                    const goldEarned = monster.gold;
                    const xpEarned = monster.xp;
                    const trophiesGained = monster.id > 100 ? (monster.id - 100) * 4 : monster.id * 5; // Simple trophy logic
                    addLog(`ÏäπÎ¶¨! ${goldEarned} GÏôÄ ${xpEarned} XP, Ìä∏Î°úÌîº ${trophiesGained}Í∞úÎ•º ÌöçÎìùÌñàÎã§!`, 'system-message');
                    
                    const townXpGained = Math.floor(monster.xp / 2);
                    if (townXpGained > 0) {
                         addLog(`ÎßàÏùÑ Í≤ΩÌóòÏπò ${townXpGained} XPÎ•º ÌöçÎìùÌñàÎã§!`, 'effect-message');
                    }

                    const itemDrops = [];
                    monster.drops?.forEach(drop => {
                        if (Math.random() < drop.chance) {
                            const droppedItem = allItems.find(item => item.id === drop.itemId);
                            if (droppedItem) {
                                itemDrops.push({ ...droppedItem, quantity: drop.quantity });
                                addLog(`${droppedItem.name}ÏùÑ(Î•º) ÌöçÎìùÌñàÎã§!`, 'effect-message');
                            }
                        }
                    });

                    setPlayerStats(prev => {
                        let newXp = prev.xp + xpEarned;
                        let newLevel = prev.level;
                        let newMaxHp = prev.maxHp;
                        let newAttack = prev.attack;
                        let newDefense = prev.defense;
                        let newXpToNextLevel = prev.xpToNextLevel;
                        let goldFromLevelUp = 0;

                        while (newXp >= newXpToNextLevel) {
                            newXp -= newXpToNextLevel;
                            newLevel++;
                            newMaxHp += 10;
                            newAttack += 2;
                            newDefense += 1;
                            newXpToNextLevel = Math.floor(newXpToNextLevel * 1.2);
                            goldFromLevelUp += newLevel * 100;
                            addLog(`Î†àÎ≤® ÏóÖ! ${newLevel}Î†àÎ≤®Ïù¥ ÎêòÏóàÎã§!`, 'system-message');
                        }
                        
                        if (goldFromLevelUp > 0) {
                             addLog(`Î†àÎ≤® ÏóÖ Î≥¥ÎÑàÏä§Î°ú ${goldFromLevelUp} GÎ•º ÌöçÎìùÌñàÎã§!`, 'system-message');
                        }

                        const newInventory = [...prev.inventory];
                        itemDrops.forEach(droppedItem => {
                            const existingItem = newInventory.find(i => i.id === droppedItem.id && !(i.enhancementLevel > 0));
                            if (existingItem) {
                                existingItem.quantity += droppedItem.quantity;
                            } else {
                                newInventory.push(droppedItem);
                            }
                        });

                         const updatedQuests = prev.activeQuests.map(quest => {
                            if (quest.isCompleted) return quest;

                            let newProgress = quest.currentProgress;
                            if (quest.type === 'DEFEAT_MONSTER' && quest.targetId === monster.id) {
                                newProgress += 1;
                            }
                            if (quest.type === 'COLLECT_ITEM') {
                                const relevantDrop = itemDrops.find(d => d.id === quest.targetId);
                                if (relevantDrop) {
                                     newProgress += relevantDrop.quantity;
                                }
                            }
                            return { ...quest, currentProgress: Math.min(quest.targetQuantity, newProgress) };
                        });

                        return {
                            ...prev,
                            hp: prev.hp, // HP no longer fully heals after battle
                            xp: newXp,
                            level: newLevel,
                            maxHp: newMaxHp,
                            attack: newAttack,
                            defense: newDefense,
                            xpToNextLevel: newXpToNextLevel,
                            gold: prev.gold + goldEarned + goldFromLevelUp,
                            inventory: newInventory,
                            trophies: prev.trophies + trophiesGained,
                            townXp: prev.townXp + townXpGained,
                            activeQuests: updatedQuests,
                        };
                    });
                } else {
                    addLog('Ìå®Î∞∞ÌñàÎã§...', 'system-message');
                    setPlayerStats(prev => ({...prev, hp: 1 })); // Revive with 1 HP
                }
            }, [addLog, monster, setPlayerStats]);
            
            const handleEnemyTurn = useCallback(() => {
                if (!monster) return;

                if (monster.statusEffects?.stun && monster.statusEffects.stun > 0) {
                    addLog(`${monster.name}Ïù¥(Í∞Ä) Í∏∞Ï†àÌï¥ÏÑú ÏõÄÏßÅÏùº Ïàò ÏóÜÎã§!`, 'system-message');
                    setMonster(prev => ({...prev, statusEffects: { stun: prev.statusEffects.stun - 1 }}));
                    setIsPlayerTurn(true);
                    return;
                }

                setEnemyAttacking(true);
                setTimeout(() => setEnemyAttacking(false), 400);

                let damage = Math.max(1, monster.attack - totalDefense);
                addLog(`${monster.name}Ïùò Í≥µÍ≤©! ${playerStats.playerName}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÎã§.`, 'enemy-turn');
                addDamagePopup(String(damage), false, 'player');
                const newPlayerHp = playerStats.hp - damage;
                setPlayerStats(prev => ({ ...prev, hp: newPlayerHp }));
                if (newPlayerHp <= 0) {
                    handleBattleEnd(false);
                } else {
                    setIsPlayerTurn(true);
                }
            }, [monster, playerStats, totalDefense, addLog, addDamagePopup, handleBattleEnd, setPlayerStats]);


            const handlePlayerAttack = () => {
                if (!isPlayerTurn || isBattleOver || !monster) return;

                setPlayerAttacking(true);
                setTimeout(() => setPlayerAttacking(false), 400);

                const weapon = playerStats.equipment.weapon;
                const accuracy = weapon?.accuracy || 0.9;

                if (Math.random() > accuracy) {
                    addLog(`${playerStats.playerName}Ïùò Í≥µÍ≤©Ïù¥ ÎπóÎÇòÍ∞îÎã§!`, 'player-turn');
                } else {
                    const baseCritChance = playerStats.playerClass === 'Archer' ? PlayerClasses.Archer.bonuses.critChance : 0;
                    const critChance = (weapon?.critChance || 0.05) + baseCritChance;
                    const isCrit = Math.random() < critChance;
                    const critMultiplier = weapon?.critDamageMultiplier || 1.5;
                    let damage = totalAttack;
                    damage = isCrit ? Math.floor(damage * critMultiplier) : damage;
                    damage = Math.max(1, damage - monster.defense);
                    
                    addLog(`${playerStats.playerName}Ïùò Í≥µÍ≤©! ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÎã§.${isCrit ? ' (ÏπòÎ™ÖÌÉÄ!)' : ''}`, 'player-turn');
                    addDamagePopup(String(damage), isCrit, 'enemy');
                    
                    const procChance = weapon?.procChance || 0;
                    if (weapon && weapon.procDamage && Math.random() < procChance) {
                        const procDamage = weapon.procDamage;
                         addLog(`${getDisplayName(weapon)}Ïùò ÌäπÏàò Ìö®Í≥º Î∞úÎèô! ${procDamage}Ïùò Ï∂îÍ∞Ä ÌîºÌï¥!`, 'effect-message');
                         damage += procDamage;
                    }

                    if (activePet && Math.random() < activePet.skillProcChance && activePet.skillEffect?.type === 'damage') {
                        const petDamage = activePet.skillEffect.amount || 0;
                        damage += petDamage;
                        addLog(`${activePet.name}Ïùò Ïä§ÌÇ¨ '${activePet.skillName}'! ${petDamage}Ïùò Ï∂îÍ∞Ä ÌîºÌï¥!`, 'player-turn', true);
                    }

                    const newMonsterHp = monster.hp - damage;
                    setMonster({ ...monster, hp: newMonsterHp });

                    if (newMonsterHp <= 0) {
                        handleBattleEnd(true);
                        return;
                    }
                }
                
                setUltimateCharge(prev => Math.min(5, prev + 1));
                setIsPlayerTurn(false);
            };

            const handleUsePotion = (itemToUse) => {
                if (!isPlayerTurn || isBattleOver || !monster) return;

                if (itemToUse.effect?.type === 'heal') {
                    setPlayerStats(prev => {
                        const newHp = Math.min(prev.maxHp, prev.hp + itemToUse.effect.amount);
                        const newInventory = prev.inventory.map(item =>
                            item.id === itemToUse.id ? { ...item, quantity: item.quantity - 1 } : item
                        ).filter(item => item.quantity > 0);
                        
                        addLog(`${playerStats.playerName}Ïù¥(Í∞Ä) ${itemToUse.name}ÏùÑ(Î•º) ÏÇ¨Ïö©Ìï¥ HPÎ•º ${itemToUse.effect.amount} ÌöåÎ≥µÌñàÎã§.`, 'player-turn');

                        return { ...prev, hp: newHp, inventory: newInventory };
                    });
                    
                    setShowInventory(false);
                    setUltimateCharge(prev => Math.min(5, prev + 1));
                    setIsPlayerTurn(false);
                } else if (itemToUse.effect?.type === 'damage_enemy') {
                    const damage = itemToUse.effect.amount;
                    addLog(`${playerStats.playerName}Ïù¥(Í∞Ä) ${itemToUse.name}ÏùÑ(Î•º) ÎçòÏ†∏ ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÎã§!`, 'player-turn');
                    addDamagePopup(String(damage), false, 'enemy');

                    const newMonsterHp = monster.hp - damage;
                    setMonster({ ...monster, hp: newMonsterHp });

                    setPlayerStats(prev => {
                        const newInventory = prev.inventory.map(item =>
                            item.id === itemToUse.id ? { ...item, quantity: item.quantity - 1 } : item
                        ).filter(item => item.quantity > 0);
                        return { ...prev, inventory: newInventory };
                    });
                    
                    setShowInventory(false);
                    setUltimateCharge(prev => Math.min(5, prev + 1));
                    
                    if (newMonsterHp <= 0) {
                        handleBattleEnd(true);
                    } else {
                        setIsPlayerTurn(false);
                    }
                }
            };

            const handleUseUltimate = () => {
                if (ultimateCharge < 5 || !isPlayerTurn || isBattleOver || !monster) return;
                
                const playerClass = playerStats.playerClass || 'Adventurer';
                let damage = 0;
                let logMessage = '';

                if (playerClass === 'Warrior') {
                    damage = Math.floor(totalAttack * 3);
                    damage = Math.max(1, damage - monster.defense);
                    const stunApplied = Math.random() < 0.5;
                    if (stunApplied) {
                        setMonster(prev => ({...prev, statusEffects: { stun: 1 }}));
                        logMessage = `${playerStats.playerName}Ïùò Í∂ÅÍ∑πÍ∏∞ '${UltimateSkills.Warrior.name}'! ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌûàÍ≥† Í∏∞Ï†àÏãúÏº∞Îã§!`;
                    } else {
                        logMessage = `${playerStats.playerName}Ïùò Í∂ÅÍ∑πÍ∏∞ '${UltimateSkills.Warrior.name}'! ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÎã§!`;
                    }
                } else if (playerClass === 'Archer') {
                    const weapon = playerStats.equipment.weapon;
                    const critMultiplier = (weapon?.critDamageMultiplier || 1.5) * 2;
                    damage = Math.floor(totalAttack * critMultiplier);
                    damage = Math.max(1, damage - monster.defense);
                    logMessage = `${playerStats.playerName}Ïùò Í∂ÅÍ∑πÍ∏∞ '${UltimateSkills.Archer.name}'! ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÏπòÎ™ÖÏ†ÅÏù∏ ÌîºÌï¥Î•º ÏûÖÌòîÎã§!`;
                } else { // Adventurer
                    damage = Math.floor(totalAttack * 2.5);
                    damage = Math.max(1, damage - monster.defense);
                    logMessage = `${playerStats.playerName}Ïùò Í∂ÅÍ∑πÍ∏∞ '${UltimateSkills.Adventurer.name}'! ${monster.name}ÏóêÍ≤å ${damage}Ïùò Í∞ïÎ†•Ìïú ÌîºÌï¥Î•º ÏûÖÌòîÎã§!`;
                }

                addLog(logMessage, 'player-turn');
                addDamagePopup(String(damage), true, 'enemy');

                const newMonsterHp = monster.hp - damage;
                setMonster(m => ({ ...m, hp: newMonsterHp }));
                
                setUltimateCharge(0);

                if (newMonsterHp <= 0) {
                    handleBattleEnd(true);
                } else {
                    setIsPlayerTurn(false);
                }
            };

            useEffect(() => {
                if (!isPlayerTurn && !isBattleOver) {
                    const timer = setTimeout(() => handleEnemyTurn(), 1000);
                    return () => clearTimeout(timer);
                }
            }, [isPlayerTurn, isBattleOver, handleEnemyTurn]);

            if (!monster) return <div className="card">Î°úÎî© Ï§ë...</div>;

            return (
                <div className="card">
                    {showInventory && (
                        <div className="modal-backdrop">
                            <div className="modal-content">
                                <h3>ÏïÑÏù¥ÌÖú ÏÇ¨Ïö©</h3>
                                <div className="battle-inventory-list">
                                    {playerConsumables.length > 0 ? playerConsumables.map(item => (
                                        <div key={item.id} className="inventory-item">
                                            <span><strong className={ItemGradeInfo[item.grade]?.class}>{getDisplayName(item)}</strong> (x{item.quantity})</span>
                                            <button onClick={() => handleUsePotion(item)}>ÏÇ¨Ïö©</button>
                                        </div>
                                    )) : <p>ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî ÏÜåÎ™®ÌíàÏù¥ ÏóÜÏäµÎãàÎã§.</p>}
                                </div>
                                <button onClick={() => setShowInventory(false)}>Îã´Í∏∞</button>
                            </div>
                        </div>
                    )}
                     <div className="combat-screen">
                        <div className={`character-container player-side ${playerAttacking ? 'attacking' : ''}`}>
                            <StatBar value={playerStats.hp} maxValue={playerStats.maxHp} color="#4caf50" label={playerStats.playerName} />
                            <span className="character">üßë‚ÄçüöÄ</span>
                            {activePet && <span className="pet-character">
                                {activePet.type === 'Griffin' ? 'ü¶Ö' : activePet.type === 'Turtle' ? 'üê¢' : 'üê≤'}
                            </span>}
                            {damagePopups.filter(p => p.target === 'player').map(p => (
                                <div key={p.id} className={`damage-popup ${p.isCrit ? 'crit' : ''}`}>{p.amount}</div>
                            ))}
                        </div>
                        <div className={`character-container enemy-side ${enemyAttacking ? 'attacking' : ''}`}>
                            <StatBar value={monster.hp} maxValue={monster.maxHp} color="#f44336" label={monster.name} />
                            <span className="character">{monster.emoji}</span>
                             {damagePopups.filter(p => p.target === 'enemy').map(p => (
                                <div key={p.id} className={`damage-popup ${p.isCrit ? 'crit' : ''}`}>{p.amount}</div>
                            ))}
                        </div>
                    </div>
                    
                    <div className="battle-log" ref={el => el?.scrollTo(0, el.scrollHeight)}>
                        {battleLog}
                    </div>

                    <div style={{ marginTop: '20px', textAlign: 'center' }}>
                        {isBattleOver ? (
                            <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                        ) : (
                            <div className="battle-actions">
                                <button onClick={handlePlayerAttack} disabled={!isPlayerTurn}>Í≥µÍ≤©</button>
                                <button onClick={() => setShowInventory(true)} disabled={!isPlayerTurn}>ÏïÑÏù¥ÌÖú</button>
                                <button onClick={handleUseUltimate} disabled={!isPlayerTurn || ultimateCharge < 5} className="ultimate-button">
                                    Í∂ÅÍ∑πÍ∏∞ ({ultimateCharge}/5)
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const ClassSelectionView = ({ playerStats, setPlayerStats, setView }) => {
            const handleSelectClass = (className) => {
                if (playerStats.playerClass) {
                    alert("Ïù¥ÎØ∏ ÏßÅÏóÖÏùÑ ÏÑ†ÌÉùÌñàÏäµÎãàÎã§.");
                    return;
                }

                const selectedClass = PlayerClasses[className];
                if (confirm(`${selectedClass.name}ÏùÑ(Î•º) ÏÑ†ÌÉùÌïòÏãúÍ≤†ÏäµÎãàÍπå? ÏßÅÏóÖÏùÄ Î≥ÄÍ≤ΩÌï† Ïàò ÏóÜÏäµÎãàÎã§.`)) {
                    setPlayerStats(prev => {
                        const bonuses = selectedClass.bonuses;
                        const newMaxHp = prev.maxHp + (bonuses.maxHp || 0);
                        return {
                            ...prev,
                            playerClass: className,
                            attack: prev.attack + (bonuses.attack || 0),
                            defense: prev.defense + (bonuses.defense || 0),
                            maxHp: newMaxHp,
                            hp: newMaxHp, // Full heal on class change
                        };
                    });
                    alert(`${selectedClass.name}(Ïúº)Î°ú Ï†ÑÏßÅÌñàÏäµÎãàÎã§!`);
                    setView(View.TOWN);
                }
            };

            if (playerStats.playerClass) {
                const currentClass = PlayerClasses[playerStats.playerClass];
                return (
                    <div className="card">
                        <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                        <h2>ÎÇòÏùò ÏßÅÏóÖ</h2>
                        <h3>{currentClass.name}</h3>
                        <p>{currentClass.description}</p>
                        <p>ÎãπÏã†ÏùÄ Ïù¥ÎØ∏ ÏûêÏã†Ïùò Í∏∏ÏùÑ Í±∑Í≥† ÏûàÏäµÎãàÎã§.</p>
                    </div>
                );
            }

            return (
                <div className="card">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>ÏßÅÏóÖ ÏÑ†ÌÉù</h2>
                    <p>10Î†àÎ≤®Ïù¥ ÎêòÏñ¥ ÏÉàÎ°úÏö¥ ÌûòÏóê ÎààÏùÑ Îñ¥ÏäµÎãàÎã§! ÎãπÏã†Ïùò Í∏∏ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî. (Ìïú Î≤à ÏÑ†ÌÉùÌïòÎ©¥ Î≥ÄÍ≤ΩÌï† Ïàò ÏóÜÏäµÎãàÎã§)</p>
                    <div className="class-selection-grid">
                        {Object.entries(PlayerClasses).map(([key, value]) => (
                            <div key={key} className="card class-card">
                                <h3>{value.name}</h3>
                                <p>{value.description}</p>
                                <button onClick={() => handleSelectClass(key)}>ÏÑ†ÌÉù</button>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const DungeonBattleView = ({ dungeon, playerStats, setPlayerStats, endDungeon }) => {
            const [currentStage, setCurrentStage] = useState(1);
            const [monster, setMonster] = useState(null);
            const [battleLog, setBattleLog] = useState([]);
            const [isPlayerTurn, setIsPlayerTurn] = useState(true);
            const [damagePopups, setDamagePopups] = useState([]);
            const [playerAttacking, setPlayerAttacking] = useState(false);
            const [enemyAttacking, setEnemyAttacking] = useState(false);
            const [ultimateCharge, setUltimateCharge] = useState(0);
            const [showInventory, setShowInventory] = useState(false);
            
            const addDamagePopup = useCallback((amount, isCrit, target) => {
                const id = Date.now() + Math.random();
                setDamagePopups(prev => [...prev, { id, amount, isCrit, target }]);
                setTimeout(() => setDamagePopups(prev => prev.filter(p => p.id !== id)), 600);
            }, []);

            const addLog = useCallback((message, type, petSkill = false) => {
                const className = petSkill ? 'pet-skill-message' : type;
                setBattleLog(prev => [...prev, <p key={prev.length} className={className}>{message}</p>]);
            }, []);

            const totalAttack = useMemo(() => {
                const weapon = playerStats.equipment.weapon;
                const weaponDamage = weapon?.damage || 0;
                const enhancementBonus = weapon?.enhancementLevel || 0;
                const petBonus = playerStats.activePetId ? playerStats.pets.find(p => p.id === playerStats.activePetId)?.attackBonus || 0 : 0;
                return playerStats.attack + weaponDamage + (enhancementBonus * 2) + petBonus;
            }, [playerStats]);

            const totalDefense = useMemo(() => {
                const armor = playerStats.equipment.armor;
                const armorDefense = armor?.defense || 0;
                const enhancementBonus = armor?.enhancementLevel || 0;
                const petBonus = playerStats.activePetId ? playerStats.pets.find(p => p.id === playerStats.activePetId)?.defenseBonus || 0 : 0;
                return playerStats.defense + armorDefense + enhancementBonus + petBonus;
            }, [playerStats]);
            
            const activePet = useMemo(() => playerStats.activePetId ? playerStats.pets.find(p => p.id === playerStats.activePetId) : null, [playerStats.activePetId, playerStats.pets]);

            const playerConsumables = useMemo(() => 
                playerStats.inventory.filter(i => i.type === ItemType.CONSUMABLE), 
                [playerStats.inventory]
            );

            useEffect(() => {
                const monsterId = dungeon.monsters[currentStage - 1];
                const newMonster = { ...allMonsters.find(m => m.id === monsterId) };
                setMonster(newMonster);
                setIsPlayerTurn(true);
                addLog(`Ïä§ÌÖåÏù¥ÏßÄ ${currentStage}: ${newMonster.name}Ïù¥(Í∞Ä) ÎÇòÌÉÄÎÇ¨Îã§!`, 'system-message');
            }, [dungeon, currentStage, addLog]);

            const handleMonsterDefeated = useCallback(() => {
                if (!monster) return;

                const goldEarned = monster.gold;
                const xpEarned = monster.xp;
                addLog(`ÏäπÎ¶¨! ${goldEarned} GÏôÄ ${xpEarned} XPÎ•º ÌöçÎìùÌñàÎã§!`, 'system-message');
                
                const townXpGained = Math.floor(monster.xp / 2);
                if (townXpGained > 0) {
                    addLog(`ÎßàÏùÑ Í≤ΩÌóòÏπò ${townXpGained} XPÎ•º ÌöçÎìùÌñàÎã§!`, 'effect-message');
                }

                const itemDrops = [];
                monster.drops?.forEach(drop => {
                    if (Math.random() < drop.chance) {
                        const droppedItem = allItems.find(item => item.id === drop.itemId);
                        if (droppedItem) {
                            itemDrops.push({ ...droppedItem, quantity: drop.quantity });
                            addLog(`${droppedItem.name}ÏùÑ(Î•º) ÌöçÎìùÌñàÎã§!`, 'effect-message');
                        }
                    }
                });

                setPlayerStats(prev => {
                    let newXp = prev.xp + xpEarned;
                    let newLevel = prev.level;
                    let newMaxHp = prev.maxHp;
                    let newAttack = prev.attack;
                    let newDefense = prev.defense;
                    let newXpToNextLevel = prev.xpToNextLevel;

                    while (newXp >= newXpToNextLevel) {
                        newXp -= newXpToNextLevel;
                        newLevel++;
                        newMaxHp += 10;
                        newAttack += 2;
                        newDefense += 1;
                        newXpToNextLevel = Math.floor(newXpToNextLevel * 1.2);
                        addLog(`Î†àÎ≤® ÏóÖ! ${newLevel}Î†àÎ≤®Ïù¥ ÎêòÏóàÎã§!`, 'system-message');
                    }

                    const newInventory = [...prev.inventory];
                    itemDrops.forEach(droppedItem => {
                        const existingItem = newInventory.find(i => i.id === droppedItem.id && !(i.enhancementLevel > 0));
                        if (existingItem) {
                            existingItem.quantity += droppedItem.quantity;
                        } else {
                            newInventory.push(droppedItem);
                        }
                    });
                    
                     const updatedQuests = prev.activeQuests.map(quest => {
                        if (quest.isCompleted) return quest;

                        let newProgress = quest.currentProgress;
                        if (quest.type === 'DEFEAT_MONSTER' && quest.targetId === monster.id) {
                            newProgress += 1;
                        }
                        if (quest.type === 'COLLECT_ITEM') {
                            const relevantDrop = itemDrops.find(d => d.id === quest.targetId);
                            if (relevantDrop) {
                                newProgress += relevantDrop.quantity;
                            }
                        }
                        return { ...quest, currentProgress: Math.min(quest.targetQuantity, newProgress) };
                    });

                    return { ...prev, xp: newXp, level: newLevel, maxHp: newMaxHp, attack: newAttack, defense: newDefense, xpToNextLevel: newXpToNextLevel, gold: prev.gold + goldEarned, inventory: newInventory, townXp: prev.townXp + townXpGained, activeQuests: updatedQuests };
                });

                if (currentStage < dungeon.stages) {
                    setTimeout(() => setCurrentStage(prev => prev + 1), 1500);
                } else {
                    addLog(`ÎçòÏ†Ñ '${dungeon.name}' ÌÅ¥Î¶¨Ïñ¥! ÏµúÏ¢Ö Î≥¥ÏÉÅÏùÑ ÌöçÎìùÌï©ÎãàÎã§!`, 'system-message');
                    setPlayerStats(prev => {
                        let finalXp = prev.xp + dungeon.rewards.xp;
                        let finalGold = prev.gold + dungeon.rewards.gold;
                        const newInventory = [...prev.inventory];
                        dungeon.rewards.items.forEach(rewardItem => {
                            addLog(`${allItems.find(i=>i.id === rewardItem.itemId)?.name} x${rewardItem.quantity} ÌöçÎìù!`, 'effect-message');
                            const itemInfo = allItems.find(i => i.id === rewardItem.itemId);
                            const existingItem = newInventory.find(i => i.id === itemInfo.id && !(i.enhancementLevel > 0));
                            if (existingItem) {
                                existingItem.quantity += rewardItem.quantity;
                            } else {
                                newInventory.push({ ...itemInfo, quantity: rewardItem.quantity });
                            }
                        });
                        return { ...prev, xp: finalXp, gold: finalGold, inventory: newInventory };
                    });
                    setTimeout(() => endDungeon(true), 2000);
                }
            }, [monster, currentStage, dungeon, addLog, setPlayerStats, endDungeon]);

            const handlePlayerDeath = useCallback(() => {
                addLog('ÎçòÏ†Ñ Í≥µÎûµ Ïã§Ìå®...', 'system-message');
                setPlayerStats(prev => ({...prev, hp: 1}));
                setTimeout(() => endDungeon(false), 2000);
            }, [addLog, setPlayerStats, endDungeon]);

            const handleEnemyTurn = useCallback(() => {
                if (!monster) return;

                if (monster.statusEffects?.stun && monster.statusEffects.stun > 0) {
                    addLog(`${monster.name}Ïù¥(Í∞Ä) Í∏∞Ï†àÌï¥ÏÑú ÏõÄÏßÅÏùº Ïàò ÏóÜÎã§!`, 'system-message');
                    setMonster(prev => ({...prev, statusEffects: { stun: prev.statusEffects.stun - 1 }}));
                    setIsPlayerTurn(true);
                    return;
                }

                setEnemyAttacking(true);
                setTimeout(() => setEnemyAttacking(false), 400);

                let damage = Math.max(1, monster.attack - totalDefense);
                addLog(`${monster.name}Ïùò Í≥µÍ≤©! ${playerStats.playerName}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÎã§.`, 'enemy-turn');
                addDamagePopup(String(damage), false, 'player');
                const newPlayerHp = playerStats.hp - damage;
                setPlayerStats(prev => ({ ...prev, hp: newPlayerHp }));
                if (newPlayerHp <= 0) {
                    handlePlayerDeath();
                } else {
                    setIsPlayerTurn(true);
                }
            }, [monster, playerStats, totalDefense, addLog, addDamagePopup, handlePlayerDeath, setPlayerStats]);

            const handlePlayerAction = (isAttack, damageDealt) => {
                if(!monster) return;
                const newMonsterHp = monster.hp - damageDealt;
                setMonster({ ...monster, hp: newMonsterHp });

                if (newMonsterHp <= 0) {
                    handleMonsterDefeated();
                } else {
                    if (isAttack) {
                         setUltimateCharge(prev => Math.min(5, prev + 1));
                    }
                    setIsPlayerTurn(false);
                }
            }

            const handlePlayerAttack = () => {
                if (!isPlayerTurn || !monster) return;
                setPlayerAttacking(true);
                setTimeout(() => setPlayerAttacking(false), 400);

                const weapon = playerStats.equipment.weapon;
                const accuracy = weapon?.accuracy || 0.9;
                let totalDamage = 0;

                if (Math.random() > accuracy) {
                    addLog(`${playerStats.playerName}Ïùò Í≥µÍ≤©Ïù¥ ÎπóÎÇòÍ∞îÎã§!`, 'player-turn');
                } else {
                    const baseCritChance = playerStats.playerClass === 'Archer' ? PlayerClasses.Archer.bonuses.critChance : 0;
                    const critChance = (weapon?.critChance || 0.05) + baseCritChance;
                    const isCrit = Math.random() < critChance;
                    const critMultiplier = weapon?.critDamageMultiplier || 1.5;
                    let damage = totalAttack;
                    damage = isCrit ? Math.floor(damage * critMultiplier) : damage;
                    damage = Math.max(1, damage - monster.defense);
                    
                    addLog(`${playerStats.playerName}Ïùò Í≥µÍ≤©! ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÎã§.${isCrit ? ' (ÏπòÎ™ÖÌÉÄ!)' : ''}`, 'player-turn');
                    addDamagePopup(String(damage), isCrit, 'enemy');
                    totalDamage += damage;
                    
                    const procChance = weapon?.procChance || 0;
                    if (weapon && weapon.procDamage && Math.random() < procChance) {
                        const procDamage = weapon.procDamage;
                         addLog(`${getDisplayName(weapon)}Ïùò ÌäπÏàò Ìö®Í≥º Î∞úÎèô! ${procDamage}Ïùò Ï∂îÍ∞Ä ÌîºÌï¥!`, 'effect-message');
                         totalDamage += procDamage;
                    }

                    if (activePet && Math.random() < activePet.skillProcChance && activePet.skillEffect?.type === 'damage') {
                        const petDamage = activePet.skillEffect.amount || 0;
                        totalDamage += petDamage;
                        addLog(`${activePet.name}Ïùò Ïä§ÌÇ¨ '${activePet.skillName}'! ${petDamage}Ïùò Ï∂îÍ∞Ä ÌîºÌï¥!`, 'player-turn', true);
                    }
                }
                
                handlePlayerAction(true, totalDamage);
            };

            const handleUsePotion = (itemToUse) => {
                if (!isPlayerTurn || !monster) return;

                if (itemToUse.effect?.type === 'heal') {
                    setPlayerStats(prev => {
                        const newHp = Math.min(prev.maxHp, prev.hp + itemToUse.effect.amount);
                        const newInventory = prev.inventory.map(item =>
                            item.id === itemToUse.id ? { ...item, quantity: item.quantity - 1 } : item
                        ).filter(item => item.quantity > 0);
                        
                        addLog(`${playerStats.playerName}Ïù¥(Í∞Ä) ${itemToUse.name}ÏùÑ(Î•º) ÏÇ¨Ïö©Ìï¥ HPÎ•º ${itemToUse.effect.amount} ÌöåÎ≥µÌñàÎã§.`, 'player-turn');
                        return { ...prev, hp: newHp, inventory: newInventory };
                    });
                    
                    setShowInventory(false);
                    setIsPlayerTurn(false);
                } else if (itemToUse.effect?.type === 'damage_enemy') {
                    const damage = itemToUse.effect.amount;
                    addLog(`${playerStats.playerName}Ïù¥(Í∞Ä) ${itemToUse.name}ÏùÑ(Î•º) ÎçòÏ†∏ ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÎã§!`, 'player-turn');
                    addDamagePopup(String(damage), false, 'enemy');

                    setPlayerStats(prev => {
                        const newInventory = prev.inventory.map(item =>
                            item.id === itemToUse.id ? { ...item, quantity: item.quantity - 1 } : item
                        ).filter(item => item.quantity > 0);
                        return { ...prev, inventory: newInventory };
                    });
                    
                    setShowInventory(false);
                    handlePlayerAction(false, damage);
                }
            };
            
            const handleUseUltimate = () => {
                if (ultimateCharge < 5 || !isPlayerTurn || !monster) return;
                const playerClass = playerStats.playerClass || 'Adventurer';
                let damage = 0;
                let logMessage = '';

                if (playerClass === 'Warrior') {
                    damage = Math.floor(totalAttack * 3);
                    damage = Math.max(1, damage - monster.defense);
                    if (Math.random() < 0.5) {
                        setMonster(prev => ({...prev, statusEffects: { stun: 1 }}));
                        logMessage = `${playerStats.playerName}Ïùò Í∂ÅÍ∑πÍ∏∞ '${UltimateSkills.Warrior.name}'! ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌûàÍ≥† Í∏∞Ï†àÏãúÏº∞Îã§!`;
                    } else {
                         logMessage = `${playerStats.playerName}Ïùò Í∂ÅÍ∑πÍ∏∞ '${UltimateSkills.Warrior.name}'! ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÎã§!`;
                    }
                } else if (playerClass === 'Archer') {
                    const critMultiplier = (playerStats.equipment.weapon?.critDamageMultiplier || 1.5) * 2;
                    damage = Math.floor(totalAttack * critMultiplier);
                    damage = Math.max(1, damage - monster.defense);
                    logMessage = `${playerStats.playerName}Ïùò Í∂ÅÍ∑πÍ∏∞ '${UltimateSkills.Archer.name}'! ${monster.name}ÏóêÍ≤å ${damage}Ïùò ÏπòÎ™ÖÏ†ÅÏù∏ ÌîºÌï¥Î•º ÏûÖÌòîÎã§!`;
                } else {
                    damage = Math.floor(totalAttack * 2.5);
                    damage = Math.max(1, damage - monster.defense);
                    logMessage = `${playerStats.playerName}Ïùò Í∂ÅÍ∑πÍ∏∞ '${UltimateSkills.Adventurer.name}'! ${monster.name}ÏóêÍ≤å ${damage}Ïùò Í∞ïÎ†•Ìïú ÌîºÌï¥Î•º ÏûÖÌòîÎã§!`;
                }

                addLog(logMessage, 'player-turn');
                addDamagePopup(String(damage), true, 'enemy');
                setUltimateCharge(0);
                handlePlayerAction(false, damage);
            };

            useEffect(() => {
                if (!isPlayerTurn && monster && monster.hp > 0 && playerStats.hp > 0) {
                    const timer = setTimeout(() => handleEnemyTurn(), 1000);
                    return () => clearTimeout(timer);
                }
            }, [isPlayerTurn, monster, playerStats.hp, handleEnemyTurn]);

            if (!monster) return <div className="card">Î°úÎî© Ï§ë...</div>;

            return (
                <div className="card">
                    <h2>{dungeon.name} - Ïä§ÌÖåÏù¥ÏßÄ {currentStage}/{dungeon.stages}</h2>
                     {showInventory && (
                        <div className="modal-backdrop">
                            <div className="modal-content">
                                <h3>ÏïÑÏù¥ÌÖú ÏÇ¨Ïö©</h3>
                                <div className="battle-inventory-list">
                                    {playerConsumables.map(item => (
                                        <div key={item.id} className="inventory-item">
                                            <span><strong className={ItemGradeInfo[item.grade]?.class}>{getDisplayName(item)}</strong> (x{item.quantity})</span>
                                            <button onClick={() => handleUsePotion(item)}>ÏÇ¨Ïö©</button>
                                        </div>
                                    ))}
                                </div>
                                <button onClick={() => setShowInventory(false)}>Îã´Í∏∞</button>
                            </div>
                        </div>
                    )}
                     <div className="combat-screen">
                         <div className={`character-container player-side ${playerAttacking ? 'attacking' : ''}`}>
                            <StatBar value={playerStats.hp} maxValue={playerStats.maxHp} color="#4caf50" label={playerStats.playerName} />
                            <span className="character">üßë‚ÄçüöÄ</span>
                             {activePet && <span className="pet-character">
                                {activePet.type === 'Griffin' ? 'ü¶Ö' : activePet.type === 'Turtle' ? 'üê¢' : 'üê≤'}
                            </span>}
                            {damagePopups.filter(p => p.target === 'player').map(p => (
                                <div key={p.id} className={`damage-popup ${p.isCrit ? 'crit' : ''}`}>{p.amount}</div>
                            ))}
                        </div>
                        <div className={`character-container enemy-side ${enemyAttacking ? 'attacking' : ''}`}>
                            <StatBar value={monster.hp} maxValue={monster.maxHp} color="#f44336" label={monster.name} />
                            <span className="character">{monster.emoji}</span>
                             {damagePopups.filter(p => p.target === 'enemy').map(p => (
                                <div key={p.id} className={`damage-popup ${p.isCrit ? 'crit' : ''}`}>{p.amount}</div>
                            ))}
                        </div>
                    </div>
                    
                    <div className="battle-log" ref={el => el?.scrollTo(0, el.scrollHeight)}>
                        {battleLog}
                    </div>

                    <div style={{ marginTop: '20px', textAlign: 'center' }}>
                        {monster.hp <= 0 || playerStats.hp <= 0 ? (
                            <p>Îã§ÏùåÏúºÎ°ú ÏßÑÌñâ Ï§ë...</p>
                        ) : (
                            <div className="battle-actions">
                                <button onClick={handlePlayerAttack} disabled={!isPlayerTurn}>Í≥µÍ≤©</button>
                                <button onClick={() => setShowInventory(true)} disabled={!isPlayerTurn}>ÏïÑÏù¥ÌÖú</button>
                                <button onClick={handleUseUltimate} disabled={!isPlayerTurn || ultimateCharge < 5} className="ultimate-button">
                                    Í∂ÅÍ∑πÍ∏∞ ({ultimateCharge}/5)
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const DungeonSelectionView = ({ setView, startDungeon }) => {
            return (
                <div className="card">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>ÎçòÏ†Ñ ÏÑ†ÌÉù</h2>
                    <div className="dungeon-list">
                        {allDungeons.map(dungeon => (
                            <div key={dungeon.id} className="card dungeon-card">
                                <h3>{dungeon.name} (Lv.{dungeon.difficulty})</h3>
                                <p>{dungeon.description}</p>
                                <p>Ïä§ÌÖåÏù¥ÏßÄ: {dungeon.stages}</p>
                                <div className="dungeon-card-rewards">
                                    <strong>Ï£ºÏöî Î≥¥ÏÉÅ:</strong>
                                    <ul>
                                        <li>{formatNumber(dungeon.rewards.gold)} G, {formatNumber(dungeon.rewards.xp)} XP</li>
                                        {dungeon.rewards.items.map(item => (
                                            <li key={item.itemId}>{allItems.find(i => i.id === item.itemId)?.name} x{item.quantity}</li>
                                        ))}
                                    </ul>
                                </div>
                                <button onClick={() => startDungeon(dungeon)}>ÏûÖÏû•</button>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const BlacksmithView = ({ playerStats, setPlayerStats, setView }) => {
            const [tab, setTab] = useState('enhance');
            const [selectedItem, setSelectedItem] = useState(null);

            const handleEnhance = () => {
                if (!selectedItem) return;

                const level = selectedItem.enhancementLevel || 0;
                const cost = 100 * (level + 1);
                const materialCost = Math.ceil((level + 1) / 2);
                const magicStone = playerStats.inventory.find(i => i.id === 12);

                if (playerStats.gold < cost) {
                    alert("Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                    return;
                }
                if (!magicStone || magicStone.quantity < materialCost) {
                    alert("ÎßàÎ†•Ïùò ÎèåÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                    return;
                }

                const successChance = Math.max(0.1, 1 - (level * 0.08));
                
                setPlayerStats(prev => {
                    const newInventory = [...prev.inventory];
                    const stoneIndex = newInventory.findIndex(i => i.id === 12);
                    newInventory[stoneIndex] = {...newInventory[stoneIndex], quantity: newInventory[stoneIndex].quantity - materialCost};

                    if (Math.random() < successChance) {
                        alert("Í∞ïÌôîÏóê ÏÑ±Í≥µÌñàÏäµÎãàÎã§!");
                        const itemIndex = newInventory.findIndex(i => i.id === selectedItem.id && i.enhancementLevel === selectedItem.enhancementLevel);
                        
                        // create a new unique item instance for the enhanced item
                        const enhancedItem = {
                            ...selectedItem,
                            enhancementLevel: level + 1,
                            quantity: 1,
                        };
                        
                        if (newInventory[itemIndex].quantity > 1) {
                            newInventory[itemIndex].quantity -= 1;
                            newInventory.push(enhancedItem);
                        } else {
                            newInventory[itemIndex] = enhancedItem;
                        }
                        
                        setSelectedItem(enhancedItem); // update selected item view
                        
                         return { ...prev, gold: prev.gold - cost, inventory: newInventory.filter(i => i.quantity > 0) };

                    } else {
                        alert("Í∞ïÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§...");
                         return { ...prev, gold: prev.gold - cost, inventory: newInventory.filter(i => i.quantity > 0) };
                    }
                });
            };

            const handleCraft = (recipe) => {
                // Check materials
                for (const mat of recipe.materials) {
                    const playerMat = playerStats.inventory.find(i => i.id === mat.materialId);
                    if (!playerMat || playerMat.quantity < mat.quantity) {
                        alert(`${allMaterials.find(m => m.id === mat.materialId)?.name}Ïù¥(Í∞Ä) Î∂ÄÏ°±Ìï©ÎãàÎã§.`);
                        return;
                    }
                }

                setPlayerStats(prev => {
                    let newInventory = [...prev.inventory];

                    // Consume materials
                    recipe.materials.forEach(mat => {
                        const matIndex = newInventory.findIndex(i => i.id === mat.materialId);
                        newInventory[matIndex].quantity -= mat.quantity;
                    });
                    newInventory = newInventory.filter(i => i.quantity > 0);

                    // Add result item
                    const existingItem = newInventory.find(i => i.id === recipe.result.id && !i.enhancementLevel);
                    if (existingItem) {
                        existingItem.quantity += 1;
                    } else {
                        newInventory.push({ ...recipe.result, quantity: 1 });
                    }
                    
                    // Check for quest progress
                    const updatedQuests = prev.activeQuests.map(quest => {
                        if (!quest.isCompleted && quest.type === 'CRAFT_ITEM' && quest.targetId === recipe.result.id) {
                             return { ...quest, currentProgress: quest.currentProgress + 1 };
                        }
                        return quest;
                    });

                    return { ...prev, inventory: newInventory, activeQuests: updatedQuests };
                });

                alert(`${recipe.result.name} Ï†úÏûëÏóê ÏÑ±Í≥µÌñàÏäµÎãàÎã§!`);
            };

            const enhanceableItems = playerStats.inventory.filter(i => (i.type === ItemType.WEAPON || i.type === ItemType.ARMOR));

            return (
                <div className="card">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>ÎåÄÏû•Í∞Ñ</h2>
                    <div className="shop-tabs">
                        <button className={tab === 'enhance' ? 'active' : ''} onClick={() => { setTab('enhance'); setSelectedItem(null); }}>Í∞ïÌôî</button>
                        <button className={tab === 'craft' ? 'active' : ''} onClick={() => { setTab('craft'); setSelectedItem(null); }}>Ï†úÏûë</button>
                    </div>
                    {tab === 'enhance' ? (
                        <div className="blacksmith-container">
                            <div className="item-list-panel">
                                <h3>Í∞ïÌôîÌï† ÏïÑÏù¥ÌÖú ÏÑ†ÌÉù</h3>
                                {enhanceableItems.map((item, index) => (
                                    <div key={`${item.id}-${index}-${item.enhancementLevel || 0}`} 
                                         className={`list-item ${selectedItem === item ? 'selected' : ''}`}
                                         onClick={() => setSelectedItem(item)}>
                                        <strong className={ItemGradeInfo[item.grade]?.class}>{getDisplayName(item)}</strong>
                                    </div>
                                ))}
                            </div>
                            <div>
                                {selectedItem ? (
                                    <div className="card">
                                        <h3>{getDisplayName(selectedItem)}</h3>
                                        <div className="enhancement-stats">
                                            {selectedItem.damage && <p>Í≥µÍ≤©Î†•: {selectedItem.damage + ((selectedItem.enhancementLevel || 0) * 2)} <span className="arrow">‚Üí</span> {selectedItem.damage + ((selectedItem.enhancementLevel || 0) + 1) * 2}</p>}
                                            {selectedItem.defense && <p>Î∞©Ïñ¥Î†•: {selectedItem.defense + (selectedItem.enhancementLevel || 0)} <span className="arrow">‚Üí</span> {selectedItem.defense + (selectedItem.enhancementLevel || 0) + 1}</p>}
                                        </div>
                                        <hr />
                                        <p><strong>ÎπÑÏö©:</strong> {100 * ((selectedItem.enhancementLevel || 0) + 1)} G</p>
                                        <p><strong>ÌïÑÏöî Ïû¨Î£å:</strong> ÎßàÎ†•Ïùò Îèå x{Math.ceil(((selectedItem.enhancementLevel || 0) + 1) / 2)}</p>
                                        <p><strong>ÏÑ±Í≥µ ÌôïÎ•†:</strong> {Math.max(10, 100 - ((selectedItem.enhancementLevel || 0) * 8))}%</p>
                                        <button onClick={handleEnhance}>Í∞ïÌôî</button>
                                    </div>
                                ) : <p>Í∞ïÌôîÌï† ÏïÑÏù¥ÌÖúÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>}
                            </div>
                        </div>
                    ) : (
                         <div className="crafting-container">
                            {allRecipes.map(recipe => {
                                const canCraft = recipe.materials.every(mat => {
                                    const playerMat = playerStats.inventory.find(i => i.id === mat.materialId);
                                    return playerMat && playerMat.quantity >= mat.quantity;
                                });

                                return (
                                    <div key={recipe.id} className="card" style={{marginBottom: '15px'}}>
                                        <h3>{recipe.name}</h3>
                                        <p>Í≤∞Í≥º: <strong className={ItemGradeInfo[recipe.result.grade]?.class}>{recipe.result.name}</strong></p>
                                        <ul className="material-list">
                                            <strong>ÌïÑÏöî Ïû¨Î£å:</strong>
                                            {recipe.materials.map(mat => {
                                                const playerMat = playerStats.inventory.find(i => i.id === mat.materialId);
                                                const haveEnough = playerMat && playerMat.quantity >= mat.quantity;
                                                return (
                                                    <li key={mat.materialId} className={haveEnough ? 'sufficient' : 'insufficient'}>
                                                        {allMaterials.find(m => m.id === mat.materialId)?.name}: {mat.quantity} (Î≥¥Ïú†: {playerMat?.quantity || 0})
                                                    </li>
                                                );
                                            })}
                                        </ul>
                                        <button onClick={() => handleCraft(recipe)} disabled={!canCraft}>Ï†úÏûë</button>
                                    </div>
                                )
                            })}
                        </div>
                    )}
                </div>
            );
        };

        const QuestBoardView = ({ playerStats, setPlayerStats, setView }) => {

            const handleAcceptQuest = (questId) => {
                const questData = allQuests.find(q => q.id === questId);
                if (questData && playerStats.activeQuests.length < 5) {
                    setPlayerStats(prev => ({
                        ...prev,
                        activeQuests: [...prev.activeQuests, { ...questData, currentProgress: 0, isCompleted: false }]
                    }));
                } else if (playerStats.activeQuests.length >= 5) {
                    alert("ÏµúÎåÄ 5Í∞úÏùò ÌÄòÏä§Ìä∏Îßå ÎèôÏãúÏóê ÏßÑÌñâÌï† Ïàò ÏûàÏäµÎãàÎã§.");
                }
            };

            const handleClaimReward = (questId) => {
                const quest = playerStats.activeQuests.find(q => q.id === questId);
                if (!quest || !quest.isCompleted) return;
                
                alert(`ÌÄòÏä§Ìä∏ '${quest.title}' Î≥¥ÏÉÅÏùÑ ÌöçÎìùÌñàÏäµÎãàÎã§!`);

                setPlayerStats(prev => {
                    let newGold = prev.gold + quest.rewards.gold;
                    let newXp = prev.xp + quest.rewards.xp;
                    let newInventory = [...prev.inventory];

                    quest.rewards.items?.forEach(rewardItem => {
                        const itemInfo = allItems.find(i => i.id === rewardItem.itemId);
                        if (itemInfo) {
                            const existingItem = newInventory.find(i => i.id === itemInfo.id && !i.enhancementLevel);
                            if (existingItem) {
                                existingItem.quantity += rewardItem.quantity;
                            } else {
                                newInventory.push({ ...itemInfo, quantity: rewardItem.quantity });
                            }
                        }
                    });
                    
                    const townXpGained = Math.floor(quest.rewards.xp / 4);

                    return {
                        ...prev,
                        gold: newGold,
                        xp: newXp,
                        inventory: newInventory,
                        townXp: prev.townXp + townXpGained,
                        activeQuests: prev.activeQuests.filter(q => q.id !== questId)
                    };
                });
            };
            
            useEffect(() => {
                // Automatically mark quests as completed
                setPlayerStats(prev => {
                    const updatedQuests = prev.activeQuests.map(quest => {
                        if (!quest.isCompleted && quest.currentProgress >= quest.targetQuantity) {
                            return { ...quest, isCompleted: true };
                        }
                        return quest;
                    });
                    return { ...prev, activeQuests: updatedQuests };
                });
            }, [playerStats.activeQuests, setPlayerStats]);
            
            const availableQuests = allQuests.filter(q => !playerStats.activeQuests.some(aq => aq.id === q.id));

            return (
                 <div className="card quest-board-container">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>ÌÄòÏä§Ìä∏ Í≤åÏãúÌåê</h2>

                    <div className="quest-section">
                        <h3>ÏßÑÌñâ Ï§ëÏù∏ ÌÄòÏä§Ìä∏ ({playerStats.activeQuests.length}/5)</h3>
                        {playerStats.activeQuests.length > 0 ? playerStats.activeQuests.map(quest => {
                            const progress = Math.min(quest.currentProgress, quest.targetQuantity);
                            return (
                                <div key={quest.id} className={`card quest-card ${quest.isCompleted ? 'completed' : ''}`}>
                                    <div className="quest-info">
                                        <h4>{quest.title}</h4>
                                        <p>{quest.description}</p>
                                        <div className="quest-progress-bar-container">
                                            <div className="quest-progress-bar-fill" style={{width: `${(progress / quest.targetQuantity) * 100}%`}}></div>
                                        </div>
                                        <span>{progress} / {quest.targetQuantity}</span>
                                        <div className="quest-rewards">
                                            <strong>Î≥¥ÏÉÅ:</strong> {quest.rewards.gold} G, {quest.rewards.xp} XP
                                        </div>
                                    </div>
                                    {quest.isCompleted && <button onClick={() => handleClaimReward(quest.id)}>Î≥¥ÏÉÅ Î∞õÍ∏∞</button>}
                                </div>
                            );
                        }) : <p>ÏßÑÌñâ Ï§ëÏù∏ ÌÄòÏä§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§.</p>}
                    </div>

                    <div className="quest-section">
                        <h3>ÏÉàÎ°úÏö¥ ÌÄòÏä§Ìä∏</h3>
                        {availableQuests.map(quest => (
                            <div key={quest.id} className="card quest-card">
                                <div className="quest-info">
                                    <h4>{quest.title}</h4>
                                    <p>{quest.description}</p>
                                     <div className="quest-rewards">
                                        <strong>Î≥¥ÏÉÅ:</strong> {quest.rewards.gold} G, {quest.rewards.xp} XP
                                    </div>
                                </div>
                                <button onClick={() => handleAcceptQuest(quest.id)} disabled={playerStats.activeQuests.length >= 5}>ÏàòÎùΩ</button>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const GachaShrineView = ({ playerStats, setPlayerStats, setView }) => {
            const [gachaResult, setGachaResult] = useState(null);

            const performItemGacha = () => {
                if (playerStats.gold < ITEM_GACHA_COST) {
                    alert("Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                    return;
                }

                setPlayerStats(prev => ({...prev, gold: prev.gold - ITEM_GACHA_COST}));

                const rand = Math.random();
                let grade;
                if (rand < 0.01) grade = ItemGrade.LEGENDARY; // 1%
                else if (rand < 0.06) grade = ItemGrade.EPIC; // 5%
                else if (rand < 0.21) grade = ItemGrade.RARE; // 15%
                else if (rand < 0.51) grade = ItemGrade.UNCOMMON; // 30%
                else grade = ItemGrade.COMMON; // 49%

                const itemsOfGrade = allItems.filter(item => item.grade === grade && item.type !== ItemType.MATERIAL);
                const drawnItem = itemsOfGrade[Math.floor(Math.random() * itemsOfGrade.length)];

                setPlayerStats(prev => {
                    const newInventory = [...prev.inventory];
                    const existingItem = newInventory.find(i => i.id === drawnItem.id && !i.enhancementLevel);
                    if (existingItem) {
                        existingItem.quantity += 1;
                    } else {
                        newInventory.push({ ...drawnItem, quantity: 1 });
                    }
                    return { ...prev, inventory: newInventory };
                });

                setGachaResult({ type: 'item', item: drawnItem });
            };
            
             const performPetGacha = () => {
                if (playerStats.gold < PET_GACHA_COST) {
                    alert("Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                    return;
                }

                setPlayerStats(prev => ({...prev, gold: prev.gold - PET_GACHA_COST}));
                
                const rand = Math.random();
                let grade;
                if (rand < 0.05) grade = ItemGrade.EPIC; // 5%
                else grade = ItemGrade.RARE; // 95%
                
                const petsOfGrade = allPets.filter(p => p.grade === grade);
                const drawnPetData = petsOfGrade[Math.floor(Math.random() * petsOfGrade.length)];
                const newPet = { ...drawnPetData, level: 1, xp: 0, xpToNextLevel: 100 };

                setPlayerStats(prev => ({ ...prev, pets: [...prev.pets, newPet]}));
                setGachaResult({ type: 'pet', pet: newPet });
            };


            return (
                <div className="card gacha-shrine">
                    {gachaResult && (
                        <div className="gacha-result" onClick={() => setGachaResult(null)}>
                            <div className="card">
                                <h2>ÌöçÎìù!</h2>
                                {gachaResult.type === 'item' && gachaResult.item && <>
                                    <p className={`gacha-item-grade ${ItemGradeInfo[gachaResult.item.grade]?.class}`}>{ItemGradeInfo[gachaResult.item.grade]?.name}</p>
                                    <p className="gacha-item-name">{gachaResult.item.name}</p>
                                </>}
                                 {gachaResult.type === 'pet' && gachaResult.pet && <>
                                    <p className={`gacha-item-grade ${ItemGradeInfo[gachaResult.pet.grade]?.class}`}>{ItemGradeInfo[gachaResult.pet.grade]?.name}</p>
                                    <p className="gacha-item-name">{gachaResult.pet.name}</p>
                                </>}
                                <button onClick={() => setGachaResult(null)}>ÌôïÏù∏</button>
                            </div>
                        </div>
                    )}
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>ÎΩëÍ∏∞ ÏÑ±ÏÜå</h2>
                    <p>Ïö¥Î™ÖÏùÑ ÏãúÌóòÌïòÍ≥† Í∞ïÎ†•Ìïú ÏïÑÏù¥ÌÖúÍ≥º Î∞òÎ†§ÎèôÎ¨ºÏùÑ ÏñªÏúºÏÑ∏Ïöî!</p>
                    <div className="gacha-buttons-container">
                        <button className="gacha-button" onClick={performItemGacha} disabled={playerStats.gold < ITEM_GACHA_COST}>
                            ÏïÑÏù¥ÌÖú ÎΩëÍ∏∞<br/>({formatNumber(ITEM_GACHA_COST)} G)
                        </button>
                         <button className="gacha-button pet-gacha-button" onClick={performPetGacha} disabled={playerStats.gold < PET_GACHA_COST}>
                            Î∞òÎ†§ÎèôÎ¨º ÎΩëÍ∏∞<br/>({formatNumber(PET_GACHA_COST)} G)
                        </button>
                    </div>
                </div>
            );
        };

        const TownHallView = ({ playerStats, setPlayerStats, setView }) => {
            const currentLevelIndex = playerStats.townLevel - 1;
            const currentLevelInfo = townLevels[currentLevelIndex];
            const nextLevelInfo = townLevels[currentLevelIndex + 1];

            const isMaxLevel = !nextLevelInfo || nextLevelInfo.costToUpgrade === Infinity;

            // XP bar calculation
            const baseXpForCurrentLevel = currentLevelInfo.xpRequired;
            const xpNeededForNextLevel = isMaxLevel ? baseXpForCurrentLevel : nextLevelInfo.xpRequired;
            const xpProgressInCurrentLevel = playerStats.townXp - baseXpForCurrentLevel;
            const xpRangeForCurrentLevel = xpNeededForNextLevel - baseXpForCurrentLevel;

            const canUpgrade = !isMaxLevel && 
                               playerStats.gold >= currentLevelInfo.costToUpgrade && 
                               playerStats.townXp >= nextLevelInfo.xpRequired;

            const handleUpgrade = () => {
                if (!canUpgrade) {
                     if (playerStats.townXp < nextLevelInfo.xpRequired) {
                        alert("ÎßàÏùÑ Í≤ΩÌóòÏπòÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                    } else if (playerStats.gold < currentLevelInfo.costToUpgrade) {
                        alert("ÏóÖÍ∑∏Î†àÏù¥Îìú ÎπÑÏö©Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                    }
                    return;
                }

                setPlayerStats(prev => {
                    alert(`ÎßàÏùÑÏùÑ Lv.${prev.townLevel + 1} ${nextLevelInfo.name}(Ïúº)Î°ú ÏóÖÍ∑∏Î†àÏù¥ÎìúÌñàÏäµÎãàÎã§!`);
                    return {
                        ...prev,
                        gold: prev.gold - currentLevelInfo.costToUpgrade,
                        townLevel: prev.townLevel + 1,
                    };
                });
            };

            return (
                <div className="card">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>ÎßàÏùÑ ÌöåÍ¥Ä</h2>
                    <h3>ÌòÑÏû¨ ÎßàÏùÑ: Lv.{playerStats.townLevel} {currentLevelInfo.name}</h3>

                    {isMaxLevel ? (
                        <p>ÎßàÏùÑÏù¥ ÏµúÍ≥† Î†àÎ≤®Ïóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§!</p>
                    ) : (
                        <div className="town-hall-content">
                            <StatBar 
                                value={xpProgressInCurrentLevel > 0 ? xpProgressInCurrentLevel : 0} 
                                maxValue={xpRangeForCurrentLevel > 0 ? xpRangeForCurrentLevel : 1} 
                                color="#03dac6" 
                                label={`ÎßàÏùÑ XP`} 
                            />
                             <div className="town-hall-upgrade-info">
                                <h4>Îã§Ïùå Î†àÎ≤®: Lv.{playerStats.townLevel + 1} {nextLevelInfo.name}</h4>
                                <p>ÌïÑÏöî Ï¥ù Í≤ΩÌóòÏπò: {formatNumber(nextLevelInfo.xpRequired)} (ÌòÑÏû¨: {formatNumber(playerStats.townXp)})</p>
                                <p>ÏóÖÍ∑∏Î†àÏù¥Îìú ÎπÑÏö©: {formatNumber(currentLevelInfo.costToUpgrade)} G</p>
                                <button onClick={handleUpgrade} disabled={!canUpgrade}>
                                    ÏóÖÍ∑∏Î†àÏù¥Îìú
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const TrophyRoadView = ({ playerStats, setPlayerStats, setView }) => {

            const handleClaimReward = (milestoneIndex) => {
                const milestone = trophyRoadMilestones[milestoneIndex];
                if (playerStats.trophies < milestone.trophies || playerStats.claimedTrophyRewards.includes(milestoneIndex)) {
                    return;
                }

                setPlayerStats(prev => {
                    let newGold = prev.gold;
                    let newInventory = [...prev.inventory];

                    if (milestone.rewards.gold) {
                        newGold += milestone.rewards.gold;
                    }
                    if (milestone.rewards.items) {
                         milestone.rewards.items.forEach(rewardItem => {
                            const itemInfo = allItems.find(i => i.id === rewardItem.itemId);
                            if(itemInfo) {
                                const existingItem = newInventory.find(i => i.id === itemInfo.id && !i.enhancementLevel);
                                if (existingItem) existingItem.quantity += rewardItem.quantity;
                                else newInventory.push({ ...itemInfo, quantity: rewardItem.quantity });
                            }
                         });
                    }
                    return {
                        ...prev,
                        gold: newGold,
                        inventory: newInventory,
                        claimedTrophyRewards: [...prev.claimedTrophyRewards, milestoneIndex]
                    };
                });
            };

            return (
                <div className="card">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>Ìä∏Î°úÌîº Î°úÎìú</h2>
                    <p className="current-trophies">ÌòÑÏû¨ Ìä∏Î°úÌîº: {formatNumber(playerStats.trophies)} üèÜ</p>
                    <div className="trophy-road-container">
                        {trophyRoadMilestones.map((milestone, index) => {
                            const isUnlocked = playerStats.trophies >= milestone.trophies;
                            const isClaimed = playerStats.claimedTrophyRewards.includes(index);
                            return (
                                <div key={index} className={`trophy-milestone ${isUnlocked ? 'unlocked' : ''} ${isClaimed ? 'claimed' : ''}`}>
                                    <div>
                                        <h4>{milestone.trophies} üèÜ</h4>
                                        <div>
                                            {milestone.rewards.gold && <p>Í≥®Îìú: {formatNumber(milestone.rewards.gold)}</p>}
                                            {milestone.rewards.items?.map(item => (
                                                <p key={item.itemId}>{allItems.find(i => i.id === item.itemId)?.name} x{item.quantity}</p>
                                            ))}
                                        </div>
                                    </div>
                                    <button onClick={() => handleClaimReward(index)} disabled={!isUnlocked || isClaimed}>
                                        {isClaimed ? 'ÌöçÎìù ÏôÑÎ£å' : 'Î≥¥ÏÉÅ Î∞õÍ∏∞'}
                                    </button>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const PetsView = ({ playerStats, setPlayerStats, setView }) => {
            const [selectedPet, setSelectedPet] = useState(null);

            useEffect(() => {
                if (playerStats.pets.length > 0 && !selectedPet) {
                    setSelectedPet(playerStats.pets[0]);
                }
            }, [playerStats.pets, selectedPet]);

            const handleSetActivePet = (petId) => {
                setPlayerStats(prev => ({ ...prev, activePetId: petId }));
            };

            return (
                <div className="card">
                    <button onClick={() => setView(View.TOWN)}>ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                    <h2>Î∞òÎ†§ÎèôÎ¨º</h2>
                    {playerStats.pets.length === 0 ? (
                        <p>Î≥¥Ïú†Ìïú Î∞òÎ†§ÎèôÎ¨ºÏù¥ ÏóÜÏäµÎãàÎã§. ÎΩëÍ∏∞ ÏÑ±ÏÜåÏóêÏÑú ÏÉàÎ°úÏö¥ ÏπúÍµ¨Î•º ÎßåÎÇòÎ≥¥ÏÑ∏Ïöî!</p>
                    ) : (
                        <div className="pet-management-view">
                            <div className="pet-list-container">
                                <h3>ÎÇòÏùò Î∞òÎ†§ÎèôÎ¨º</h3>
                                <div className="pet-list">
                                    {playerStats.pets.map(pet => (
                                        <div key={pet.id} className={`pet-card ${selectedPet?.id === pet.id ? 'active' : ''}`} onClick={() => setSelectedPet(pet)}>
                                            <strong className={ItemGradeInfo[pet.grade]?.class}>{pet.name}</strong>
                                            <span> (Lv.{pet.level})</span>
                                            {playerStats.activePetId === pet.id && ' ‚úÖ'}
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <div className="pet-details-container card">
                                {selectedPet ? (
                                    <>
                                        <h3>{selectedPet.name} <span className={ItemGradeInfo[selectedPet.grade]?.class}>({ItemGradeInfo[selectedPet.grade]?.name})</span></h3>
                                        <p>Î†àÎ≤®: {selectedPet.level}</p>
                                        <StatBar value={selectedPet.xp} maxValue={selectedPet.xpToNextLevel} color="#fbc02d" label="XP" />
                                        <p>Í≥µÍ≤©Î†• Î≥¥ÎÑàÏä§: +{selectedPet.attackBonus}</p>
                                        <p>Î∞©Ïñ¥Î†• Î≥¥ÎÑàÏä§: +{selectedPet.defenseBonus}</p>
                                        <hr />
                                        <h4>Ïä§ÌÇ¨: {selectedPet.skillName}</h4>
                                        <p>{selectedPet.skillDescription}</p>
                                        <button onClick={() => handleSetActivePet(selectedPet.id)} disabled={playerStats.activePetId === selectedPet.id}>
                                            {playerStats.activePetId === selectedPet.id ? 'ÌôúÏÑ±ÌôîÎê®' : 'ÌôúÏÑ±Ìôî'}
                                        </button>
                                    </>
                                ) : <p>Î∞òÎ†§ÎèôÎ¨ºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const App = () => {
            const [playerStats, setPlayerStats] = useState(null);
            const [view, setView] = useState(View.TOWN);
            const [selectedDungeon, setSelectedDungeon] = useState(null);

            useEffect(() => {
                const savedData = localStorage.getItem('playerStats');
                if (savedData) {
                    setPlayerStats(JSON.parse(savedData));
                } else {
                    setPlayerStats(getInitialPlayerStats());
                }
            }, []);

            useEffect(() => {
                if (playerStats) {
                    localStorage.setItem('playerStats', JSON.stringify(playerStats));
                }
            }, [playerStats]);

            // Full HP recovery in town
            useEffect(() => {
                if (view === View.TOWN) {
                    setPlayerStats(prev => {
                        if (prev && prev.hp < prev.maxHp) {
                            return { ...prev, hp: prev.maxHp };
                        }
                        return prev;
                    });
                }
            }, [view]);
            
            const resetGame = () => {
                if (confirm("Ï†ïÎßêÎ°ú Î™®Îì† ÏßÑÌñâ ÏÉÅÌô©ÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.")) {
                    localStorage.removeItem('playerStats');
                    setPlayerStats(getInitialPlayerStats());
                    setView(View.TOWN);
                }
            };
            
            const startDungeon = (dungeon) => {
                if (!playerStats) return;

                let finalDungeon = { ...dungeon };
                // ÌîåÎ†àÏù¥Ïñ¥ Î†àÎ≤®Ïù¥ 10 ÎØ∏ÎßåÏù¥Î©¥ ÎçòÏ†Ñ Í∞ÄÎîîÏñ∏(id: 4)ÏùÑ Ïò§ÌÅ¨(id: 3)Î°ú ÍµêÏ≤¥Ìï©ÎãàÎã§.
                if (playerStats.level < 10) {
                    finalDungeon.monsters = dungeon.monsters.map(monsterId => monsterId === 4 ? 3 : monsterId);
                }
                
                setSelectedDungeon(finalDungeon);
                setView(View.DUNGEON_BATTLE);
            };

            const renderView = () => {
                if (!playerStats) return <div>Í≤åÏûÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</div>;

                switch (view) {
                    case View.TOWN:
                        return <TownView playerStats={playerStats} setView={setView} />;
                    case View.PLAYER:
                        return <PlayerStatsView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.SHOP:
                        return <ShopView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.BATTLE:
                        return <BattleView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.CLASS_SELECTION:
                         return <ClassSelectionView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.DUNGEON:
                        return <DungeonSelectionView setView={setView} startDungeon={startDungeon} />;
                    case View.DUNGEON_BATTLE:
                        return <DungeonBattleView dungeon={selectedDungeon} playerStats={playerStats} setPlayerStats={setPlayerStats} endDungeon={() => { setView(View.TOWN); }} />;
                    case View.BLACKSMITH:
                        return <BlacksmithView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.QUEST_BOARD:
                        return <QuestBoardView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.GACHA_SHRINE:
                        return <GachaShrineView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.TOWN_HALL:
                        return <TownHallView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.TROPHY_ROAD:
                        return <TrophyRoadView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    case View.PETS:
                         return <PetsView playerStats={playerStats} setPlayerStats={setPlayerStats} setView={setView} />;
                    default:
                        return <TownView playerStats={playerStats} setView={setView} />;
                }
            };

            return (
                <>
                    {renderView()}
                    <button onClick={resetGame} style={{ marginTop: '20px', backgroundColor: '#555' }}>Í≤åÏûÑ Ï¥àÍ∏∞Ìôî</button>
                </>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>